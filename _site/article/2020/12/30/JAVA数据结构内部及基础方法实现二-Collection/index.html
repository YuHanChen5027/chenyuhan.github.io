<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta name="description" content="关于Android开发| 这里是 陈宇瀚 的个人博客，一个有梦想还没秃的Android程序员。">
    <meta name="keywords"  content="陈宇瀚, ChenYuhan, Android, 陈宇瀚的博客, Java ">
    <meta name="theme-color" content="#000000">
    
    <!-- Open Graph -->
    <meta property="og:title" content="JAVA数据结构内部及基础方法实现二（Collection） - 陈宇瀚的博客 | ChenYuHan Blog">
    
    <meta property="og:type" content="article">
    <meta property="og:description" content="JAVA有几种常用的数据结构，主要是继承Collection和Map这两个主要接口的数据实现类
">
    
    <meta property="article:published_time" content="2020-12-30T16:35:00Z">
    
    
    <meta property="article:author" content="陈宇瀚">
    
    
    <meta property="article:tag" content="JAVA">
    
    <meta property="article:tag" content="数据结构">
    
    
    <meta property="og:image" content="https://yuhanchen5027.github.io//img/avatar-cyh.png">
    <meta property="og:url" content="https://yuhanchen5027.github.io//article/2020/12/30/JAVA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%86%85%E9%83%A8%E5%8F%8A%E5%9F%BA%E7%A1%80%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%BA%8C-Collection/">
    <meta property="og:site_name" content="陈宇瀚的博客 | ChenYuHan Blog">
    
    <title>JAVA数据结构内部及基础方法实现二（Collection） - 陈宇瀚的博客 | ChenYuHan Blog</title>

    <!-- Web App Manifest -->
    <link rel="manifest" href="/pwa/manifest.json">

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/favicon.ico">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://yuhanchen5027.github.io//article/2020/12/30/JAVA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%86%85%E9%83%A8%E5%8F%8A%E5%9F%BA%E7%A1%80%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%BA%8C-Collection/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->

    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">ChenYuHan Blog</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div id="huxblog_navbar">
                <div class="navbar-collapse">
                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="/">Home</a>
                        </li>
                        
                        
                        
                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                        
                        
                        <li>
                            <a href="/archive/">Archive</a>
                        </li>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <li class="search-icon">
                            <a href="javascript:void(0)">
                                <i class="fa fa-search"></i>
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <script>
        // Drop Bootstarp low-performance Navbar
        // Use customize navbar with high-quality material design animation
        // in high-perf jank-free CSS3 implementation
        var $body = document.body;
        var $toggle = document.querySelector('.navbar-toggle');
        var $navbar = document.querySelector('#huxblog_navbar');
        var $collapse = document.querySelector('.navbar-collapse');

        var __HuxNav__ = {
            close: function () {
                $navbar.className = " ";
                // wait until animation end.
                setTimeout(function () {
                    // prevent frequently toggle
                    if ($navbar.className.indexOf('in') < 0) {
                        $collapse.style.height = "0px"
                    }
                }, 400)
            },
            open: function () {
                $collapse.style.height = "auto"
                $navbar.className += " in";
            }
        }

        // Bind Event
        $toggle.addEventListener('click', function (e) {
            if ($navbar.className.indexOf('in') > 0) {
                __HuxNav__.close()
            } else {
                __HuxNav__.open()
            }
        })

        /**
         * Since Fastclick is used to delegate 'touchstart' globally
         * to hack 300ms delay in iOS by performing a fake 'click',
         * Using 'e.stopPropagation' to stop 'touchstart' event from 
         * $toggle/$collapse will break global delegation.
         * 
         * Instead, we use a 'e.target' filter to prevent handler
         * added to document close HuxNav.  
         *
         * Also, we use 'click' instead of 'touchstart' as compromise
         */
        document.addEventListener('click', function (e) {
            if (e.target == $toggle) return;
            if (e.target.className == 'icon-bar') return;
            __HuxNav__.close();
        })
    </script>
    <!-- Search -->
<div class="search-page">
  <div class="search-icon-close-container">
    <span class="search-icon-close">
      <i class="fa fa-chevron-down"></i>
    </span>
  </div>
  <div class="search-main container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <form></form>
        <input type="text" id="search-input" placeholder="$ grep...">
        </form>
        <div id="search-results" class="mini-post-list"></div>
      </div>
    </div>
  </div>
</div>

    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/home-bg.jpg" width="0" height="0"> -->

<!-- Post Header -->



<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/home-bg.jpg');
        background: ;
    }

    
</style>

<header class="intro-header" >

    <div class="header-mask"></div>
    
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/archive/?tag=JAVA" title="JAVA">JAVA</a>
                        
                        <a class="tag" href="/archive/?tag=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" title="数据结构">数据结构</a>
                        
                    </div>
                    <h1>JAVA数据结构内部及基础方法实现二（Collection）</h1>
                    
                    <h2 class="subheading"></h2>
                    <span class="meta">Posted by 陈宇瀚 on December 30, 2020</span>
                </div>
            </div>
        </div>
    </div>
</header>






<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <!-- Multi-Lingual -->
                

				<p>JAVA有几种常用的数据结构，主要是继承<strong>Collection</strong>和<strong>Map</strong>这两个主要接口的数据实现类</p>

<p>在jdk1.7和jdk1.8中，实现会有些许不同，之后会在注解中添加两版本区别
下面分别介绍几个常用的数据结构(按照继承的接口分为两类)，以下代码截取自<strong>基于JAVA8的android SDK 28</strong></p>
<h1 id="collection">Collection</h1>
<p><strong>Collection</strong>是最基本的集合接口，一个<strong>Collection</strong>代表一组<strong>Object</strong>，即<strong>Collection</strong>的元素<strong>Elements</strong>。一些<strong>Collection</strong>允许相同的元素而另一些不行。一些能排序而另一些不行。<strong>Java SDK</strong>不提供直接继承自<strong>Collection</strong>的类，<strong>Java SDK</strong>提供的类都是继承自<strong>Collection的</strong>“子接口”如<strong>List</strong>和<strong>Set</strong>。</p>

<p>论<strong>Collection</strong>的实际类型如何，它都支持一个<strong>iterator</strong>()的方法，该方法返回一个<strong>迭代子</strong>，使用该迭代子即可逐一访问<strong>Collection</strong>中每一个元素。典型的用法如下：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>Iterator it = collection.iterator(); // 获得一个迭代子
　　　　while(it.hasNext()) {
　　　　　　Object obj = it.next(); // 得到下一个元素
　　　　}
</pre></td></tr></tbody></table></code></pre></div></div>
<p>由<strong>Collection</strong>接口派生的两个接口是<strong>List</strong>和<strong>Set</strong>。</p>
<h2 id="list">List</h2>
<p><strong>List</strong>是有序的<strong>Collection</strong>，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在<strong>List</strong>中的位置，类似于数组下标）来访问<strong>List</strong>中的元素，这类似于<strong>Java</strong>的数组，与之后介绍的<strong>Set</strong>不一样，<strong>List</strong>允许有相同的元素。实现<strong>List</strong>接口的常用类有<strong>LinkedList</strong>，<strong>ArrayList</strong>，<strong>Vector</strong>和<strong>Stack</strong>。</p>

<h3 id="linkedlistjava78中基本没有改动">LinkedList（JAVA7/8中基本没有改动）</h3>
<p>双向链表结构，适用于乱序插入、删除。但指定序列操作性能不如<strong>ArrayList</strong>。</p>

<p><strong>LinkedList</strong>的父类接口，以及内部有几个主要的变量，如下：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>public class LinkedList&lt;E&gt;
    extends AbstractSequentialList&lt;E&gt;
    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable
    
transient int size = 0;//链表尺寸
transient Node&lt;E&gt; first;//链表第一个节点指针
transient Node&lt;E&gt; last;//链表末尾节点指针

##注transient关键字：将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会被序列化。

</pre></td></tr></tbody></table></code></pre></div></div>
<p><em>注：实现了Cloneable接口，即实现clone()函数。代表能被克隆。</em>
数据类<strong>Node</strong>的结构</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre>  private static class Node&lt;E&gt; {
        E item;//节点数据
        Node&lt;E&gt; next;//当前节点下一个节点
        Node&lt;E&gt; prev;//当前节点上一个节点

        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="构造方法">构造方法</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre> public LinkedList() {
 }
 //构造一个包含指定元素的列表
 public LinkedList(Collection&lt;? extends E&gt; c) {
        this();
        addAll(c);
}
    
public boolean addAll(Collection&lt;? extends E&gt; c) {
        //可参考下方的addAll解析，就是在size(此时size = 0)后加入指定元素的列表的数据
        return addAll(size, c);
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>以下是使用时的常用方法实现代码以及分析:</p>

<p><em>注：modCount是父类AbstractList中定义的一个int型的属性记录了ArrayList结构性变化的次数。List中add()、remove()、addAll()、removeRange()及clear()这些方法每调用一次，modCount的值就加1。</em></p>

<h4 id="addaddlasteaddinte">add()/addLast(E)/add(int,E)</h4>
<p><strong>add(E)/addLast(E)</strong>:将指定的元素添加到列表的末尾。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre>public boolean add(E e) {
        linkLast(e);
        return true;
    }
public void addLast(E e) {
        linkLast(e);
    }
    
    void linkLast(E e) {
        final Node&lt;E&gt; l = last;//获取末尾节点
        final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);//将传入的数据封装成 Node
        last = newNode; 
        if (l == null)//判断是否存在末尾节点
            first = newNode;//不存在则说明链表为空，直接将节点赋值为 newNode
        else
            l.next = newNode;//否则将末尾节点的next赋值为 newNode
        size++;
        modCount++;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<p><strong>add(int,E)</strong>:在列表的指定位置插入指定的元素。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre> public void add(int index, E element) {
        //判断index下标是否在链表范围内(0=&lt;index&lt;=size),超出则抛出IndexOutOfBoundsException 
        checkPositionIndex(index);

        if (index == size)
            linkLast(element); //此时相当于插入末尾，与add(E)方法一致
        else
            linkBefore(element, node(index));//重点看这个方法，插入链表中间
    }
    
     /**
     * 在节点index前插入新节点
     */
    void linkBefore(E e, Node&lt;E&gt; succ) {
        final Node&lt;E&gt; pred = succ.prev;//获得index位置节点的前置节点
        //创建新节点，前置节点为index位置节点的前置节点，后置节点为index位置节点
        final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);
        succ.prev = newNode;//改变index位置节点的前置节点为新节点
        if (pred == null) //判断index位置节点的前置节点是否为空
            first = newNode;    //为空代表插在链表头
        else
            pred.next = newNode;    //不为空将节点的后置节点设置为新节点
        size++;
        modCount++;
        
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="removeint">remove(int)</h4>
<p><strong>remove(int)</strong>：删除列表中指定位置的元素。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="rouge-code"><pre> public E remove(int index) {
        /**判断index下标是否在链表索引范围内(0=&lt;index&lt;size),超出则抛出IndexOutOfBoundsException**/
        checkElementIndex(index);
        return unlink(node(index));//node(index)获取到了index下表的Node
    }
    
    E unlink(Node&lt;E&gt; x) {
        // assert x != null;
        final E element = x.item;
        final Node&lt;E&gt; next = x.next;
        final Node&lt;E&gt; prev = x.prev;
        //判断前置节点是否为null。
        if (prev == null) {
            first = next;//为空则代表是第一个节点，将后置节点设置为首位节点
        } else {
            //不为空则代表是中间节点，将前置节点的后置节点设置为自己的后直节点，断开自己与前置节点的链接。
            prev.next = next 
            x.prev = null;
        }
        //同样的方式判断后置
        if (next == null) {
            last = prev;
        } else {
            next.prev = prev;
            x.next = null;
        }
            
        x.item = null;//当前节点的数据置null
        size--;
        modCount++;
        return element; 
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="getint">get(int)</h4>
<p><strong>get(int)</strong>:Returns the element at the specified position in this list.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre>public E get(int index){
        /**判断index下标是否在链表索引范围内(0=&lt;index&lt;size),超出则抛出IndexOutOfBoundsException**/
        checkElementIndex(index);
        return node(index).item;
    }
    
    /**
    *   返回指定元素索引处的(非空)节点。
    */
    Node&lt;E&gt; node(int index) {
        /**size &gt;&gt; 1相当于size/2**/
        if (index &lt; (size &gt;&gt; 1)) { 
          /**如果获取index小于size/2，则从首位节点开始循环获取**/
            Node&lt;E&gt; x = first;  
            for (int i = 0; i &lt; index; i++)
                x = x.next;
            return x;
        } else {
          /**如果获取index大于size/2，则从末尾节点开始循环获取**/
            Node&lt;E&gt; x = last;
            for (int i = size - 1; i &gt; index; i--)
                x = x.prev;
            return x;
        }
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="setinte">set(int,E)</h4>
<p><strong>set(int,E)</strong>:将列表中指定位置的元素替换为指定的元素。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>  public E set(int index, E element) {
        /**判断index下标是否在链表索引范围内(0=&lt;index&lt;size),超出则抛出IndexOutOfBoundsException**/
        checkElementIndex(index);
        Node&lt;E&gt; x = node(index);
        E oldVal = x.item;
        x.item = element;
        return oldVal;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="addallcollection-extends-eaddallint--collection-extends-e">addAll(Collection&lt;? extends E&gt;)/addAll(int , Collection&lt;? extends E&gt;)</h4>
<p><strong>addAll(Collection&lt;? extends E&gt;)/addAll(int , Collection&lt;? extends E&gt;)</strong>
：将指定集合中的所有元素添加到末尾/index节点之后</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td><td class="rouge-code"><pre>   //本质上是调用同个方法
   public boolean addAll(Collection&lt;? extends E&gt; c) {
        return addAll(size, c);//传入size,直接在末尾插入
    }
    
    public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
        //判断插入位置index是否超出范围
        checkPositionIndex(index);
        //将集合转成数组
        Object[] a = c.toArray();
        int numNew = a.length;
        //集合数为0，等于没有数据
        if (numNew == 0)
            return false;

        //predpred是插入节点集合的前置节点
        //succ是插入位置节点，用于之后判断是中间插入还是末尾插入
        Node&lt;E&gt; pred, succ;
        if (index == size) {
            //index等于链表尺寸，代表是末尾插入
            succ = null;
            pred = last;
        } else {
            //中间插入，保留插入位置的节点
            succ = node(index); 
            pred = succ.prev;
        }

        for (Object o : a) {
            @SuppressWarnings("unchecked") E e = (E) o;
            Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null);
            if (pred == null) 
                //前置节点为null,相当于插入链表头
                first = newNode;
            else
                //不为空，则从插入位置之后插入
                pred.next = newNode;
            pred = newNode;
        }
        //插入完成后，判断插入位置succ
        if (succ == null) {
            //succ为null,代表末尾插入
            last = pred;
        } else {
            //succ不为null,代表中间插入，设置插入全部数据后的最后一个数据节点后置节点为succ
            pred.next = succ;
            succ.prev = pred;
        }

        size += numNew;
        modCount++;
        return true;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="clear">clear()</h4>
<p><strong>clear()</strong>:从列表中删除所有元素。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre>public void clear() {
        //将链表中间的节点内容都设置为null
        for (Node&lt;E&gt; x = first; x != null; ) {
            Node&lt;E&gt; next = x.next;
            x.item = null;
            x.next = null;
            x.prev = null;
            x = next;
        }
        //将首位节点和末尾节点设置为null，尺寸设置为0
        first = last = null;
        size = 0;
        modCount++;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<p>还有一些其他方法，但都是基于以上方法的逻辑，就不介绍了。</p>

<h3 id="arraylist以下代码基于java8">ArrayList（以下代码基于JAVA8）</h3>
<p><strong>ArrayList</strong>是动态数组，底层就是一个数组, 因此按序查找快, 乱序插入, 删除因为涉及到后面元素移位所以性能慢。
首先需要介绍一个<strong>ArrayList</strong>方法内常用的一个方法<strong>Arrays.copyOf(T[],int)</strong>，作用是复制数组，在<strong>ArrayList</strong>初始化，扩容时都会用到，代码如下</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre> //第一个参数是原始数组，第二个是返回数组的长度
 public static &lt;T&gt; T[] copyOf(T[] original, int newLength) {
        return (T[]) copyOf(original, newLength, original.getClass());
 }
 ////第一个参数是原始数组，第二个是返回数组的长度，第三个返回数组的类
 public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) {
        @SuppressWarnings("unchecked")
        //判断返回数组的类是否是Object,是的话就创建一个Object数组，不是的话就创建一个特定类的数组
        T[] copy = ((Object)newType == (Object)Object[].class)
            ? (T[]) new Object[newLength]
            : (T[]) Array.newInstance(newType.getComponentType(), newLength);
        //将original从第0个下标开始的Math.min(original.length, newLength)的数据拷贝至copy数组的第0个下标
        System.arraycopy(original, 0, copy, 0,
                         Math.min(original.length, newLength));
        return copy;
 }

</pre></td></tr></tbody></table></code></pre></div></div>
<p><strong>ArrayList</strong>的父类接口，以及内部有几个主要的变量，如下：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre> public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
    
 private static final int DEFAULT_CAPACITY = 10;//默认初始容量
 private static final Object[] EMPTY_ELEMENTDATA = {};//用于空实例的共享空数组实例。
 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
transient Object[] elementData;//存储数组列表元素的数组缓冲区。
private int size;//实际元素个数

 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;//要分配的数组的最大大小，超出的话可能会导致OutOfMemoryError
</pre></td></tr></tbody></table></code></pre></div></div>
<p><strong>EMPTY_ELEMENTDATA</strong>和<strong>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</strong>都是空数组，区别主要是为了判断是使用了哪种构造函数，无参构造创建时使用的是<strong>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</strong>，有参构造创建时，当<strong>initialCapacity == 0</strong>使用的是<strong>EMPTY_ELEMENTDATA</strong>。以便确认如何扩容(下面会分析)。</p>

<p><em>注：RandmoAccess接口，即提供了随机访问功能。</em></p>
<h3 id="构造方法-1">构造方法</h3>
<p><strong>构造方法</strong>:<strong>ArrayList</strong>构造方法分为三个：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="rouge-code"><pre>//置为DEFAULTCAPACITY_EMPTY_ELEMENTDATA的空列表，之后会在第一次添加元素时扩容成10容量。
public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }
    
public ArrayList(int initialCapacity) {
        if (initialCapacity &gt; 0) {
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        }
    }
/**
*   按照集合的迭代器返回元素的顺序构造一个包含指定集合元素的列表。
*/
 public ArrayList(Collection&lt;? extends E&gt; c) {
        //将集合转成数组直接赋值给elementData
        elementData = c.toArray();
        if ((size = elementData.length) != 0) {
            // c.toArray might (incorrectly) not return Object[] (see 6260652)
            if (elementData.getClass() != Object[].class)
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        } else {
            // replace with empty array.
            this.elementData = EMPTY_ELEMENTDATA;
        }
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<ul>
  <li>空参构造方法：将<strong>elementData</strong>设置为<strong>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</strong>，最后会初始化成一个容量为10的空数组；</li>
  <li>带<strong>int</strong>参数的构造方法：将<strong>elementData</strong>实例化成传入的初始容量大小的数组，若传入的值为0，则将<strong>elementData</strong>设置为<strong>EMPTY_ELEMENTDATA</strong>；</li>
  <li>带<strong>Collection</strong>参数的构造方法：按照传入的集合构造一个包含指定元素的列表，r将集合转成数组直接赋值给<strong>elementData</strong>，将元素个数赋值给<strong>size</strong>，若元素个数不为0，最后将<strong>elementData</strong>转换成Object[]类的数组，若元素个数为0，则将<strong>elementData</strong>置为<strong>EMPTY_ELEMENTDATA</strong>；</li>
</ul>

<p>总的来说：</p>
<ul>
  <li>无参构造:<strong>elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA</strong>;</li>
  <li>有参构造:</li>
  <li>
    <ul>
      <li><strong>initialCapacity==0, elementData = EMPTY_ELEMENTDATA</strong></li>
    </ul>
  </li>
  <li>
    <ul>
      <li><strong>initialCapacity &gt; 0, elementData = new Object[initialCapacity];</strong></li>
    </ul>
  </li>
</ul>

<p>以下是使用时的常用方法实现代码以及分析:</p>
<h4 id="addeaddinte">add(E)/add(int,E)</h4>
<p><strong>add(E)</strong>:将指定的元素添加到列表的末尾，调用过程如下。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td><td class="rouge-code"><pre> public boolean add(E e) {
        //判断增加一个元素后的容量是否超出当前数组容量，超过扩容，不超过则不变
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        //将当前数组最后一个数据后的位置赋值为e
        elementData[size++] = e;
        return true;
 }
    
    private void ensureCapacityInternal(int minCapacity) {
        //判断当前elementData是否等于DEFAULTCAPACITY_EMPTY_ELEMENTDATA
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            //将所需大小设置成DEFAULT_CAPACITY(10)和minCapacity中比较大的值
            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
        }

        ensureExplicitCapacity(minCapacity);
    }
    
        private void ensureExplicitCapacity(int minCapacity) {
            modCount++;
        
            // 如果所需的最小容量大于当前elementData的长度
            if (minCapacity - elementData.length &gt; 0)
            grow(minCapacity);
        }
        
    //根据minCapacity(需要的最小容量)扩容
    private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;//获得当前数组长度
        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//新容量为原容量的1.5倍
        if (newCapacity - minCapacity &lt; 0) 
            //如果新容量仍小于所需最小容量，直接将新容量置为需要的最小容量
            newCapacity = minCapacity;  
        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
            //判断当前容量是否超出可分配的最大容量，超出则设置新容量为
            //Integer.MAX_VALUE，保证数组容量不超过Integer.MAX_VALUE
            newCapacity = hugeCapacity(minCapacity);
            
        //根据新容量创建新的数组赋值给elementData，此时minCapacity通常接近size
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
    
    private static int hugeCapacity(int minCapacity) {
        if (minCapacity &lt; 0) // overflow
            throw new OutOfMemoryError();
        //Integer.MAX_VALUE = MAX_ARRAY_SIZE + 8;
        return (minCapacity &gt; MAX_ARRAY_SIZE) ?
            Integer.MAX_VALUE :
            MAX_ARRAY_SIZE;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<p><strong>add(int,E)</strong>:在列表中的指定位置插入指定的元素。将当前位于该位置的元素(如果有的话)和随后的元素向右移动(下标加1)。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre> public void add(int index, E element) {
        //插入位置超过当前数据尺寸或者插入位置小于0
        if (index &gt; size || index &lt; 0)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
        
        //判断插入数据后的数据是否超出数组范围，超出则扩容，不超出则不变
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        //将elementData数组从index以及之后的数据拷贝至index+1的位置
        //相当于腾出index这个下标的位置，用于存放插入的数据element
        System.arraycopy(elementData, index, elementData, index + 1,
                         size - index);
        elementData[index] = element;
        size++;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="removeint-1">remove(int)</h4>
<p><strong>remove(int):</strong>:删除列表中指定位置的元素。将所有后续元素向左移动(从它们的下标减去1)。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre> public E remove(int index) {
        //判断是否超出范围
        if (index &gt;= size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));

        modCount++;
        //获得删除位置的数据
        E oldValue = (E) elementData[index];
        
        //删除后需要移动的数据数量。
        //例共10个数据，删除第5个数据(下标index = 4)，
        //那么需要移动的数据是第五个数据后的数据。也就是10- 4 -1 =5 个数据
        int numMoved = size - index - 1;
        
        //需要移动的数据大于0
        if (numMoved &gt; 0)
            //将elementData数组的第index+1位置开始的numMoved个数据复制到index(即数据往前移一位)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
                            
        //最后一个数据置为null，同时size-1; 
        elementData[--size] = null; // clear to let GC do its work
        //返回删除的数据
        return oldValue;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="gete">get(E)</h4>
<p><strong>get(E)</strong>:返回列表中指定位置的元素。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre> public E get(int index) {
        if (index &gt;= size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
        
        return (E) elementData[index];
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="setinte-1">set(int,E)</h4>
<p><strong>set(int,E)</strong>:用指定的元素替换列表中指定位置的元素。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>public E set(int index, E element) {
        if (index &gt;= size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));

        E oldValue = (E) elementData[index];
        elementData[index] = element;
        return oldValue;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="addallcollection-extends-eaddallint--collection-extends-e-1">addAll(Collection&lt;? extends E&gt;)/addAll(int , Collection&lt;? extends E&gt;)</h4>
<p><strong>addAll(Collection&lt;? extends E&gt;)</strong>:将指定集合中的所有元素追加到末尾</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre> public boolean addAll(Collection&lt;? extends E&gt; c) {
        //将集合转成数组，并获取数组长度
        Object[] a = c.toArray();
        int numNew = a.length;
        
        //判断追加后元素是否会超出数组范围，超出则扩容
        ensureCapacityInternal(size + numNew);  // Increments modCount
        //将追加数组a从0开始numNew(所有)数据拷贝至elementData的size下标后
        System.arraycopy(a, 0, elementData, size, numNew);
        size += numNew;
        //返回追加数组数据是否有数据
        return numNew != 0;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<p><strong>addAll(int , Collection&lt;? extends E&gt;)</strong>:将指定集合中的所有元素插入到此列表中，从指定位置开始。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre>public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
        if (index &gt; size || index &lt; 0)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
        //将集合转成数组，并获取数组长度
        Object[] a = c.toArray();
        int numNew = a.length;
        //判断插入后元素是否会超出数组范围，超出则扩容
        ensureCapacityInternal(size + numNew);  // Increments modCount
        
        //插入数据后需要移动的数据量
        int numMoved = size - index;
        if (numMoved &gt; 0)
            //将elementData数组的第index位置开始的numMoved个数据复制到index+numNew(即数据往后移numNew位)，腾出numNew个位置存放插入元素
            System.arraycopy(elementData, index, elementData, index + numNew,
                             numMoved);
        //将a数组的数据复制至elementData刚才腾出的位置
        System.arraycopy(a, 0, elementData, index, numNew);
        size += numNew;
        return numNew != 0;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="clear-1">clear()</h4>
<p><strong>clear()</strong>:从列表中删除所有元素。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre> public void clear() {
        modCount++;

        // clear to let GC do its work
        for (int i = 0; i &lt; size; i++)
            elementData[i] = null;

        size = 0;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<p><strong>ArrayList</strong>内部还有一个用于分页查看的<strong>SubList</strong>的内部类，在<strong>subList(int,int)</strong>内部会调用，作用是返回一个List集合的其中一部分视图。本质也是对<strong>elementData</strong>这个数组进行操作，这里就不展开。</p>

<p><em>注：在无参初始化ArrayList时，Java7是直接初始化10大小的数组，而JAVA8是初始化空数组，在第一次扩容时才按照10进行扩容</em></p>
<h3 id="vector">Vector</h3>
<p><strong>Vector</strong>是矢量队列，与<strong>ArrayList</strong>不同，<strong>Vector</strong>中的操作是<strong>线程安全</strong>的。
<strong>Vector</strong>的父类接口，以及内部有几个主要的变量，如下：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>public class Vector&lt;E&gt;
    extends AbstractList&lt;E&gt;
    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
    
    protected Object[] elementData;//存储矢量组件的数组缓冲区。
    protected int elementCount;//实际元素个数
    protected int capacityIncrement;//capacityIncrement是每次Vector容量增加时的增量值，如果&lt;=0，则每次扩容时容量翻倍，否则就扩容后容量就只是容量+增量。
    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;//要分配的数组的最大大小，超出的话可能会导致OutOfMemoryError
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="构造方法-2">构造方法</h4>
<p><strong>构造方法</strong>:<strong>Vector</strong>构造方法分为三个：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre> public Vector() {
        //初始化容量为10
        this(10);
    }
    
 public Vector(int initialCapacity) {
        //初始化增量为0
        this(initialCapacity, 0);
    }
    
 public Vector(int initialCapacity, int capacityIncrement) {
        super();
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        this.elementData = new Object[initialCapacity];
        this.capacityIncrement = capacityIncrement;
    }
    
 public Vector(Collection&lt;? extends E&gt; c) {
        elementData = c.toArray();
        elementCount = elementData.length;
        // c.toArray might (incorrectly) not return Object[] (see 6260652)
        if (elementData.getClass() != Object[].class)
            elementData = Arrays.copyOf(elementData, elementCount, Object[].class);
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<p>前三个构造方法本质是调用一个方法：初始化一个特定容量的数组，初始化特定增量值，具体的初始化参数看源码；</p>

<p>带<strong>Collection</strong>参数的构造方法：按照传入的集合构造一个包含指定元素的列表，r将集合转成数组直接赋值给<strong>elementData</strong>，将元素个数赋值给<strong>elementCount</strong>，最后将<strong>elementData</strong>转换成Object[]类的数组；</p>
<h4 id="addeaddinte-1">add(E)/add(int,E)</h4>
<p><strong>add(E)</strong>:将指定的元素添加到Vector的末尾。<strong>synchronized</strong>方法，线程安全。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="rouge-code"><pre>  public synchronized boolean add(E e) {
        modCount++;
        //容量判断，容量不够则扩容，不然则不变
        ensureCapacityHelper(elementCount + 1);
        elementData[elementCount++] = e;
        return true;
    }
    
  private void ensureCapacityHelper(int minCapacity) {
        // overflow-conscious code
        if (minCapacity - elementData.length &gt; 0)
            grow(minCapacity);
    }
    
  private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        //如果设定的capacityIncrement增量大于0，则新容量为旧容量+增量，否则为双倍旧容量
        int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?
                                         capacityIncrement : oldCapacity);
        //判断新容量是否大于所需的最小容量，小于则新容量改为minCapacity
        if (newCapacity - minCapacity &lt; 0)
            newCapacity = minCapacity;
        //判断新容量是否超出
        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
            //判断当前容量是否超出可分配的最大容量，超出则设置新容量为
            //Integer.MAX_VALUE，保证数组容量不超过Integer.MAX_VALUE
            newCapacity = hugeCapacity(minCapacity);
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
    
  private static int hugeCapacity(int minCapacity) {
        if (minCapacity &lt; 0) // overflow
            throw new OutOfMemoryError();
        return (minCapacity &gt; MAX_ARRAY_SIZE) ?
            Integer.MAX_VALUE :
            MAX_ARRAY_SIZE;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<p><strong>add(int,E)</strong>：在Vector的指定位置插入指定元素。该方法内部调用的方法有<strong>synchronized</strong>，所以也是线程安全的。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre> public void add(int index, E element) {
        insertElementAt(element, index);
    }
 /**
  * 在指定的{@code index}处将指定的对象作为这个向量中的组件插入。
  *这个向量中的每个索引值大于或等于指定的{@code index}的组件向上移动，使其索引值比之前的值大1。
  */
 public synchronized void insertElementAt(E obj, int index) {
        modCount++;
        //判断插入位置是否超出范围
        if (index &gt; elementCount) {
            throw new ArrayIndexOutOfBoundsException(index
                                                     + " &gt; " + elementCount);
        }
        //容量判断，容量不够则扩容，不然则不变
        ensureCapacityHelper(elementCount + 1);
        //腾出数组中index下标位置
        System.arraycopy(elementData, index, elementData, index + 1, elementCount - index);
        //将obj插入这个位置
        elementData[index] = obj;
        elementCount++;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="removeint-2">remove(int)</h4>
<p><strong>remove(int)</strong>:移除Vector中指定位置的元素。线程安全</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre> public synchronized E remove(int index) {
        modCount++;
        if (index &gt;= elementCount)
            throw new ArrayIndexOutOfBoundsException(index);
        E oldValue = elementData(index);
        
        //numMoved需要移动的数据数量
        int numMoved = elementCount - index - 1;
        if (numMoved &gt; 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--elementCount] = null; // Let gc do its work

        return oldValue;
    }

</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="gete-1">get(E)</h4>
<p><strong>get(E)</strong>:返回该Vector中指定位置的元素。线程安全</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre> public synchronized E get(int index) {
        if (index &gt;= elementCount)
            throw new ArrayIndexOutOfBoundsException(index);

        return elementData(index);
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="setinte-2">set(int,E)</h4>
<p><strong>set(int,E)</strong>:用指定的元素替换Vector中指定位置的元素。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre> public synchronized E set(int index, E element) {
        if (index &gt;= elementCount)
            throw new ArrayIndexOutOfBoundsException(index);

        E oldValue = elementData(index);
        elementData[index] = element;
        return oldValue;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="addallcollection-extends-eaddallint--collection-extends-e-2">addAll(Collection&lt;? extends E&gt;)/addAll(int , Collection&lt;? extends E&gt;)</h4>
<p><strong>addAll(Collection&lt;? extends E&gt;)</strong>：将指定集合中的所有元素追加到末尾，线程安全</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre> public synchronized boolean addAll(Collection&lt;? extends E&gt; c) {
        modCount++;
        Object[] a = c.toArray();
        int numNew = a.length;
        //判断容量
        ensureCapacityHelper(elementCount + numNew);
        //拷贝数据
        System.arraycopy(a, 0, elementData, elementCount, numNew);
        elementCount += numNew;
        return numNew != 0;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<p><strong>addAll(int , Collection&lt;? extends E&gt;)</strong>:将指定集合中的所有元素插入到Vector的指定位置。线程安全</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre>  public synchronized boolean addAll(int index, Collection&lt;? extends E&gt; c) {
        modCount++;
        if (index &lt; 0 || index &gt; elementCount)
            throw new ArrayIndexOutOfBoundsException(index);

        Object[] a = c.toArray();
        int numNew = a.length;
        //判断容量
        ensureCapacityHelper(elementCount + numNew);
        //计算需要移动的元素数量
        int numMoved = elementCount - index;
        if (numMoved &gt; 0)
            //移动数据，腾出numNew个位置
            System.arraycopy(elementData, index, elementData, index + numNew,
                             numMoved);
        //拷贝数据至腾出的位置
        System.arraycopy(a, 0, elementData, index, numNew);
        elementCount += numNew;
        return numNew != 0;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="clear-2">clear();</h4>
<p><strong>clear()</strong>:从Vector中删除所有元素。线程安全</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre> public void clear() {
        removeAllElements();
    }
    
 public synchronized void removeAllElements() {
        modCount++;
        // Let gc do its work
        for (int i = 0; i &lt; elementCount; i++)
            elementData[i] = null;

        elementCount = 0;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<p>从代码可以得知，其实<strong>Vector</strong>就是线程安全的<strong>ArrayList</strong>，方法内的代码逻辑基本一致，就是多增加了<strong>synchronized</strong>关键字。同时因为<strong>Vector</strong>是同步的，当一个<strong>Iterator</strong>被创建而且正在被使用，另一个线程改变了<strong>Vector</strong>的状态（例如，添加或删除了一些元素），这时调用<strong>Iterator</strong>的方法时将抛出<strong>ConcurrentModificationException</strong>，因此必须捕获该异常。</p>
<h3 id="stack">Stack</h3>
<p><strong>Stack</strong>继承自<strong>Vector</strong>，实现一个<strong>后进先出</strong>的堆栈。<strong>Stack</strong>提供5个额外的方法使得<strong>Vector</strong>得以被当作堆栈使用。基本的<strong>push</strong>和<strong>pop</strong>方法，还有<strong>peek</strong>方法得到栈顶的元素，<strong>empty</strong>方法测试堆栈是否为空，<strong>search</strong>方法检测一个元素在堆栈中的位置。<strong>Stack</strong>刚创建后是空栈。</p>
<h4 id="构造方法-3">构造方法</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre> //创建一个空堆栈。
 public Stack() {
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="pushe">push(E)</h4>
<p><strong>push(E)</strong>:将E推到堆栈的顶部.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre> public E push(E item) {
        addElement(item);

        return item;
    }
 //Vector的方法
 public synchronized void addElement(E obj) {
        modCount++;
        ensureCapacityHelper(elementCount + 1);
        elementData[elementCount++] = obj;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="peek">peek()</h4>
<p><strong>peek()</strong>:查看堆栈顶部的对象，而不将其从堆栈中移除。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre> public synchronized E peek() {
        int     len = size();

        if (len == 0)
            throw new EmptyStackException();
        return elementAt(len - 1);
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="pop">pop()</h4>
<p><strong>pop()</strong>:删除堆栈顶部的对象，并将该对象作为函数的值返回。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre>     public synchronized E pop() {
        E       obj;
        int     len = size();

        obj = peek();
        removeElementAt(len - 1);

        return obj;
    }
    
    //Vector中的方法，移除指定位置的元素，并将之后的数据向前移动一位
    public synchronized void removeElementAt(int index) {
        modCount++;
        if (index &gt;= elementCount) {
            throw new ArrayIndexOutOfBoundsException(index + " &gt;= " +
                                                     elementCount);
        }
        else if (index &lt; 0) {
            throw new ArrayIndexOutOfBoundsException(index);
        }
        int j = elementCount - index - 1;
        if (j &gt; 0) {
            System.arraycopy(elementData, index + 1, elementData, index, j);
        }
        elementCount--;
        elementData[elementCount] = null; /* to let gc do its work */
    }
    
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="empty">empty()</h4>
<p><strong>empty()</strong>:查看此堆栈是否为空。本质是看数据size是否为0</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre> public boolean empty() {
        return size() == 0;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="searchobject">search(Object)</h4>
<p><strong>search(Object)</strong>:返回对象在堆栈中的基于1(即栈顶)的位置。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="rouge-code"><pre>public synchronized int search(Object o) {
        int i = lastIndexOf(o);
        
        
        if (i &gt;= 0) {
            return size() - i;
        }
        return -1;
    }
//Vector中的方法,返回Vector中指定元素最后一次出现的索引，如果vector中不包含该元素，则返回-1。
public synchronized int lastIndexOf(Object o) {
        return lastIndexOf(o, elementCount-1);
    }
//Vector中的方法,从index往回搜索值等于o的元素，返回Vector中指定元素最后一次出现的索引，如果没有找到该元素则返回-1。
public synchronized int lastIndexOf(Object o, int index) {
        if (index &gt;= elementCount)
            throw new IndexOutOfBoundsException(index + " &gt;= "+ elementCount);

        if (o == null) {
            for (int i = index; i &gt;= 0; i--)
                if (elementData[i]==null)
                    return i;
        } else {
            for (int i = index; i &gt;= 0; i--)
                if (o.equals(elementData[i]))
                    return i;
        }
        return -1;
    }
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="set">Set</h2>
<p><strong>Set</strong>是一种不包含重复的元素的<strong>Collection</strong>，即任意的两个元素e1和e2都有e1.equals(e2)=false，<strong>Set</strong>最多有一个<strong>null</strong>元素。</p>
<h3 id="hashset">HashSet</h3>
<p><strong>HashSet</strong>这个类实现了<strong>Set</strong>集合，实际内部是使用<strong>HashMap</strong>的实例。<strong>HashSet</strong>中对重复元素的理解：和通常意义上的理解不太一样！
两个元素（对象）的<strong>hashCode</strong>返回值相同，并且<strong>equals</strong>返回值为<strong>true</strong>时（或者<strong>地址</strong>相同时），才称这两个元素是相同的。
<strong>HashSet</strong>的父类接口，以及内部有几个主要的变量，如下：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>public class HashSet&lt;E&gt;
    extends AbstractSet&lt;E&gt;
    implements Set&lt;E&gt;, Cloneable, java.io.Serializable
    
    private transient HashMap&lt;E,Object&gt; map;
    //HashMap每个键值对应的value
    private static final Object PRESENT = new Object();
</pre></td></tr></tbody></table></code></pre></div></div>
<p>可以看到<strong>HashSet</strong>内部其实是由<strong>HashMap</strong>组成，<strong>HashMap</strong>是一种存储键值对的哈希表.</p>
<h4 id="构造方法-4">构造方法</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre> //构造一个新的空集合;支持HashMap实例具有默认初始容量(16)和负载系数(0.75)。
 public HashSet() {
        map = new HashMap&lt;&gt;();
    }
 //构造一个包含指定元素的的新集合;创建的HashMap实例具有默认初始容量(16和c.size()/.75f(后者约为c.size()的1.3倍)两者中的最大值)和负载系数(0.75)。
 public HashSet(Collection&lt;? extends E&gt; c) {
        map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16));
        addAll(c);
    }
 //构造一个新的空集合;内部构造指定初始容量的HashMap实例
 public HashSet(int initialCapacity) {
        map = new HashMap&lt;&gt;(initialCapacity);
    }
    
 //构造一个新的空集合;内部构造指定初始容量和指定负载系数的HashMap实例
 public HashSet(int initialCapacity, float loadFactor) {
        map = new HashMap&lt;&gt;(initialCapacity, loadFactor);
    }

 //构造一个新的、空的链接哈希集。(这个包的私有构造函数仅由LinkedHashSet使用。)后备HashMap实例是具有指定初始容量和指定负载系数的LinkedHashMap。 
 HashSet(int initialCapacity, float loadFactor, boolean dummy) {
        map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="addeaddinte-2">add(E)/add(int,E)</h4>
<p><strong>add(E)</strong>:如果E还不存在的话，将指定的元素添加到这个集合中。如果存在，则值不变直接返回false;</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>  public boolean add(E e) {
        return map.put(e, PRESENT)==null;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<p>代码可以看出</p>
<h4 id="removeint如果指定的元素存在则从集合中移除该元素返回集合中是否包含此元素">remove(int):如果指定的元素存在，则从集合中移除该元素。返回集合中是否包含此元素。</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>   public boolean remove(Object o) {
        return map.remove(o)==PRESENT;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="containsobject">contains(Object)</h4>
<p><strong>contains(Object)</strong>:返回<strong>HashSet</strong>中是否包含此元素</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>  public boolean contains(Object o) {
        return map.containsKey(o);
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="clear-3">clear()</h4>
<p><strong>clear()</strong>:从集合中删除所有元素。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre> public void clear() {
        map.clear();
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="总结">总结</h4>
<p><strong>HashSet</strong>基本所有方法都是直接调用<strong>HashMap</strong>的方法，为了保证数据不重复，采用了存储时用<strong>key</strong>存储的方法，再<strong>HashMap</strong>中,<strong>key</strong>是不重复的，所以<strong>HashSet</strong>就不会有存储重复的数据了。
<em>HashSet是线程不同步的</em></p>
<h3 id="treeset">TreeSet</h3>
<p><strong>TreeSet</strong>是一个有序的集合，它的作用是提供有序的Set集合。<strong>TreeSet</strong>的元素支持2种排序方式：自然排序或者根据提供的Comparator进行排序。</p>


                <hr style="visibility: hidden;">
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/article/2020/12/20/JAVA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%86%85%E9%83%A8%E5%8F%8A%E5%9F%BA%E7%A1%80%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B8%80-Map/" data-toggle="tooltip" data-placement="top" title="JAVA数据结构内部及基础方法实现一（Map）">
                        Previous<br>
                        <span>JAVA数据结构内部及基础方法实现一（Map）</span>
                        </a>
                    </li>
                    
                    
                </ul>
                <hr style="visibility: hidden;">

                

                
            </div>  

    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                


<section>
    
        <hr class="hidden-sm hidden-xs">
    
    <h5><a href="/archive/">FEATURED TAGS</a></h5>
    <div class="tags">
        
        
        
        
        
        
                <a data-sort="0005" 
                    href="/archive/?tag=Android"
                    title="Android"
                    rel="6">Android</a>
        
                <a data-sort="0007" 
                    href="/archive/?tag=Framework"
                    title="Framework"
                    rel="4">Framework</a>
        
                <a data-sort="0008" 
                    href="/archive/?tag=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"
                    title="数据结构"
                    rel="3">数据结构</a>
        
                <a data-sort="0008" 
                    href="/archive/?tag=JAVA"
                    title="JAVA"
                    rel="3">JAVA</a>
    </div>
</section>


                <!-- Friends Blog -->
                
<hr>
<h5>FRIENDS</h5>
<ul class="list-inline">
  
  <li><a href="https://gitee.com/5027">陈宇瀚gitee</a></li>
  
  <li><a href="https://www.jianshu.com/u/c241df6b66d1">简书</a></li>
  
  <li><a href="https://kkyflying.github.io/">Kky</a></li>
  
  <li><a href="https://kkyflying.github.io/">Kky</a></li>
  
  <li><a href="https://gitee.com/kevin.qiu">Kevin Qiu</a></li>
  
  <li><a href="https://gitee.com/rainccrun">rainccrun</a></li>
  
  <li><a href="https://gitee.com/lzxnagi">lzxnagi</a></li>
  
</ul>

            </div>
        </div>
    </div>
</article>

<!-- add support for mathjax by voleking-->









<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'right',
          // icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- SNS Link -->
                


<ul class="list-inline text-center">


  
  
  
  
  <li>
    <a target="_blank" href="http://weibo.com/陈瀚仔">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
  
  <li>
    <a target="_blank" href="https://github.com/YuHanChen5027">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-github fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
</ul>

                <p class="copyright text-muted">
                    Copyright &copy; ChenYuHan Blog 2021
                    <br>
                    Powered by <a href="http://huangxuan.me">Hux Blog</a> |
                    <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="100px"
                        height="20px"
                        src="https://ghbtns.com/github-btn.html?user=huxpro&repo=huxpro.github.io&type=star&count=true">
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<!-- Currently, only navbar scroll-down effect at desktop still depends on this -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>

<!-- Simple Jekyll Search -->
<script src="/js/simple-jekyll-search.min.js"></script>

<!-- Service Worker -->

<script src="/js/snackbar.js "></script>
<script src="/js/sw-registration.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
        var d = document, t = 'script',
            o = d.createElement(t),
            s = d.getElementsByTagName(t)[0];
        o.src = u;
        if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
        s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
     - https://github.com/jneen/rouge/wiki/list-of-supported-languages-and-lexers
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->







<!--fastClick.js -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function () {
        var $nav = document.querySelector("nav");
        if ($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->



<!-- Baidu Tongji -->



<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog(selector) {

        // interop with multilangual 
        if ('' == 'true') {
            _containerSelector = 'div.post-container.active'
        } else {
            _containerSelector = 'div.post-container'
        }

        // init
        var P = $(_containerSelector), a, n, t, l, i, c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        // clean
        $(selector).html('')

        // appending
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#" + $(this).prop('id');
            t = $(this).text();
            c = $('<a href="' + i + '" rel="nofollow">' + t + '</a>');
            l = $('<li class="' + n + '_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function (e) {
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>



<!-- Multi-Lingual -->


<!-- Simple Jekyll Search -->
<script>
    // https://stackoverflow.com/questions/1912501/unescape-html-entities-in-javascript
    function htmlDecode(input) {
        var e = document.createElement('textarea');
        e.innerHTML = input;
        // handle case of empty input
        return e.childNodes.length === 0 ? "" : e.childNodes[0].nodeValue;
    }

    SimpleJekyllSearch({
        searchInput: document.getElementById('search-input'),
        resultsContainer: document.getElementById('search-results'),
        json: '/search.json',
        searchResultTemplate: '<div class="post-preview item"><a href="{url}"><h2 class="post-title">{title}</h2><h3 class="post-subtitle">{subtitle}</h3><hr></a></div>',
        noResultsText: 'No results',
        limit: 50,
        fuzzy: false,
        // a hack to get escaped subtitle unescaped. for some reason, 
        // post.subtitle w/o escape filter nuke entire search.
        templateMiddleware: function (prop, value, template) {
            if (prop === 'subtitle' || prop === 'title') {
                if (value.indexOf("code")) {
                    return htmlDecode(value);
                } else {
                    return value;
                }
            }
        }
    });

    $(document).ready(function () {
        var $searchPage = $('.search-page');
        var $searchOpen = $('.search-icon');
        var $searchClose = $('.search-icon-close');
        var $searchInput = $('#search-input');
        var $body = $('body');

        $searchOpen.on('click', function (e) {
            e.preventDefault();
            $searchPage.toggleClass('search-active');
            var prevClasses = $body.attr('class') || '';
            setTimeout(function () {
                $body.addClass('no-scroll');
            }, 400)

            if ($searchPage.hasClass('search-active')) {
                $searchClose.on('click', function (e) {
                    e.preventDefault();
                    $searchPage.removeClass('search-active');
                    $body.attr('class', prevClasses);  // from closure 
                });
                $searchInput.focus();
            }
        });
    });
</script>


<!-- Image to hack wechat -->
<img src="/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
