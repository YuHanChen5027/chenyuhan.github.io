I"ò½<p>JAVAæœ‰å‡ ç§å¸¸ç”¨çš„æ•°æ®ç»“æ„ï¼Œä¸»è¦æ˜¯ç»§æ‰¿<strong>Collection</strong>å’Œ<strong>Map</strong>è¿™ä¸¤ä¸ªä¸»è¦æ¥å£çš„æ•°æ®å®ç°ç±»</p>

<p>åœ¨jdk1.7å’Œjdk1.8ä¸­ï¼Œå®ç°ä¼šæœ‰äº›è®¸ä¸åŒï¼Œä¹‹åä¼šåœ¨æ³¨è§£ä¸­æ·»åŠ ä¸¤ç‰ˆæœ¬åŒºåˆ«
ä¸‹é¢åˆ†åˆ«ä»‹ç»å‡ ä¸ªå¸¸ç”¨çš„æ•°æ®ç»“æ„(æŒ‰ç…§ç»§æ‰¿çš„æ¥å£åˆ†ä¸ºä¸¤ç±»)ï¼Œä»¥ä¸‹ä»£ç æˆªå–è‡ª<strong>åŸºäºJAVA8çš„android SDK 28</strong></p>
<h1 id="map">Map</h1>
<p><strong>Map</strong>æ¥å£æä¾›<strong>key</strong>åˆ°<strong>value</strong>çš„æ˜ å°„ã€‚ä¸€ä¸ª<strong>Map</strong>ä¸­ä¸èƒ½åŒ…å«ç›¸åŒçš„<strong>key</strong>ï¼Œæ¯ä¸ª<strong>key</strong>åªèƒ½æ˜ å°„ä¸€ä¸ª<strong>value</strong>ã€‚<strong>Map</strong>æ¥å£æä¾›3ç§é›†åˆçš„è§†å›¾ï¼Œ<strong>Map</strong>çš„å†…å®¹å¯ä»¥è¢«å½“ä½œä¸€ç»„<strong>key</strong>é›†åˆï¼Œä¸€ç»„<strong>value</strong>é›†åˆï¼Œæˆ–è€…ä¸€ç»„<strong>key-value</strong>æ˜ å°„ã€‚</p>

<h2 id="hashmapä»¥ä¸‹æºç åŸºäºjava8ä¸java7æœ‰è¾ƒå¤§å·®åˆ«">HashMap(ä»¥ä¸‹æºç åŸºäºJAVA8ï¼Œä¸JAVA7æœ‰è¾ƒå¤§å·®åˆ«)</h2>
<p><strong>HashMap</strong>ç»§æ‰¿<strong>Map</strong>æ¥å£ï¼Œå®ç°ä¸€ä¸ªkey-valueæ˜ å°„çš„å“ˆå¸Œè¡¨ã€‚æ˜¯éåŒæ­¥çš„ï¼ŒåŒæ—¶å…è®¸n<strong>ull value</strong>å’Œ<strong>null key</strong>ã€‚
<strong>HashMap</strong>çš„çˆ¶ç±»æ¥å£ï¼Œä»¥åŠå†…éƒ¨æœ‰å‡ ä¸ªä¸»è¦çš„å˜é‡ï¼Œå¦‚ä¸‹ï¼š</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, Serializable 

//é»˜è®¤çš„åˆå§‹å®¹é‡-å¿…é¡»æ˜¯2çš„å¹‚ã€‚
static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16
//æœ€å¤§å®¹é‡ï¼Œå¦‚æœä¸¤ä¸ªå¸¦å‚æ•°çš„æ„é€ å‡½æ•°ä¸­çš„ä»»ä½•ä¸€ä¸ªéšå¼æŒ‡å®šäº†æ›´é«˜çš„å€¼ï¼Œåˆ™ä½¿ç”¨è¯¥å€¼ã€‚ä¸€å®šæ˜¯2çš„å¹‚&lt;= 1&lt;&lt;30ã€‚
static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;
//æœªè®¾ç½®è´Ÿè½½ç³»ç»Ÿæ—¶é»˜è®¤çš„è´Ÿè½½ç³»æ•°/åŠ è½½å› å­ã€‚
static final float DEFAULT_LOAD_FACTOR = 0.75f;
//å®¹å™¨è®¡æ•°é˜ˆå€¼,å½“tableå¯¹åº”hashä½ç½®çš„é“¾è¡¨å…ƒç´ æ•°é‡è¶…è¿‡è¿™ä¸ªé˜ˆå€¼ï¼Œè¯¥ä½ç½®çš„é“¾è¡¨ä¼šè½¬æ¢ä¸ºçº¢é»‘æ ‘
static final int TREEIFY_THRESHOLD = 8;
//å®¹å™¨è®¡æ•°é˜ˆå€¼,å½“tableå¯¹åº”hashä½ç½®çš„çº¢é»‘æ ‘å…ƒç´ æ•°é‡å°é›¨è¿™ä¸ªé˜ˆå€¼ï¼Œè¯¥ä½ç½®çš„çº¢é»‘æ ‘ä¼šè½¬æ¢ä¸ºå•é“¾è¡¨
static final int UNTREEIFY_THRESHOLD = 6;

static final int MIN_TREEIFY_CAPACITY = 64;
//å­˜æ”¾æ•°æ®çš„è¡¨ï¼Œå°±æ˜¯HashMapæ•°æ®åŸºç±»çš„æ•°ç»„ï¼Œåœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨æ—¶è¿›è¡Œåˆå§‹åŒ–ï¼Œå¹¶æ ¹æ®éœ€è¦è°ƒæ•´å¤§å°ã€‚åˆ†é…æ—¶ï¼Œé•¿åº¦æ€»æ˜¯2çš„å¹‚ã€‚
transient Node&lt;K,V&gt;[] table;
//æ­¤Mapæ˜ å°„ä¸­åŒ…å«çš„é”®-å€¼å¯¹çš„æ•°é‡ã€‚
transient int size;
//(threshold = å®¹é‡*è´Ÿè½½ç³»æ•°/åŠ è½½å› å­)æ‰©å®¹é˜ˆå€¼ï¼Œå¯ä»¥è¯´æ˜¯ä¸€ä¸ªæ˜¯å¦éœ€è¦æ‰©å®¹çš„åˆ¤æ–­æ¡ä»¶ï¼Œå½“HashMapçš„size&gt;thresholdæ—¶ä¼šè¿›è¡Œresizeæ“ä½œã€‚
int threshold;
//è´Ÿè½½ç³»æ•°/åŠ è½½å› å­ï¼Œå¯ä»¥è¯´æ˜¯å½“å‰HashMapæ»¡çš„ç¨‹åº¦ï¼Œ
//å‡è®¾å®ƒç­‰äº0.75ï¼Œé‚£ä¹ˆåœ¨HashMapçš„é”®å€¼å¯¹æ•°é‡è¶…è¿‡å®¹é‡*0.75æ—¶ï¼Œåˆ™ä¼šè¿›è¡Œæ‰©å®¹ã€‚
//ä¿è¯æœ‰è¶³å¤Ÿçš„ç©ºé—´è¿›è¡Œæ•°æ®å­˜æ”¾ï¼ŒåŒæ—¶ä¸ä¼šç»å¸¸è¿›è¡Œæ‰©å®¹ã€‚
final float loadFactor;
</pre></td></tr></tbody></table></code></pre></div></div>
<p><strong>Node</strong>:<strong>HashMap</strong>çš„æ•°æ®åŸºç±»</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="rouge-code"><pre>static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
        //hashå€¼
        final int hash;
        final K key;
        V value;
        //ä¸‹ä¸€ä¸ªå¯¹è±¡
        Node&lt;K,V&gt; next;

        Node(int hash, K key, V value, Node&lt;K,V&gt; next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }

        public final K getKey()        { return key; }
        public final V getValue()      { return value; }
        public final String toString() { return key + "=" + value; }

        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

        public final V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }

        public final boolean equals(Object o) {
            if (o == this)
                return true;
            if (o instanceof Map.Entry) {
                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;
                if (Objects.equals(key, e.getKey()) &amp;&amp;
                    Objects.equals(value, e.getValue()))
                    return true;
            }
            return false;
        }
    }
    
    //JAVA8å¼•å…¥çº¢é»‘æ ‘TreeNodeï¼Œä¹‹åä¼šåˆ†æ
    static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.LinkedHashMapEntry&lt;K,V&gt;
</pre></td></tr></tbody></table></code></pre></div></div>
<p><strong>Node</strong>æ˜¯ä¸€ä¸ªå•é“¾è¡¨ç»“æ„çš„ç±»ï¼Œç”±äº<strong>HashMap</strong>å­˜å‚¨å¥å€¼å¯¹æ—¶ï¼Œä¼šå…ˆå°†<strong>key</strong>è½¬æˆ<strong>hash</strong>ä¸å½“å‰å®¹é‡-1è¿›è¡Œä¸€ä¸ªä¸æ“ä½œ( (n - 1) &amp; hash)è½¬æ¢æˆä¸€ä¸ª<strong>ä¸‹æ ‡å€¼</strong>ï¼Œåœ¨æ•°ç»„ä¸­å¯¹åº”ä¸€ä¸ª<strong>Node</strong>ï¼Œæ‰€ä»¥ä¼šå­˜åœ¨è½¬æ¢å‡ºæ¥çš„<strong>ä¸‹æ ‡å€¼</strong>ç›¸åŒ(<strong>å“ˆå¸Œå†²çª</strong>)ï¼Œä½†<strong>key</strong>ä¸åŒçš„æƒ…å†µï¼Œæ‰€ä»¥åŒä¸€ä¸ª<strong>ä¸‹æ ‡å€¼</strong>å¯èƒ½å¯¹åº”ä¸åŒçš„å¥å€¼å¯¹ã€‚æ‰€ä»¥tableæ•°ç»„é‡‡ç”¨<strong>Node</strong>è¿™ä¸ªå•é“¾è¡¨çš„ä½œä¸ºå­˜å‚¨åŸºç±»ï¼Œç”¨äºå­˜æ”¾è¿™äº›<strong>ä¸‹æ ‡å€¼</strong>ç›¸åŒï¼Œä½†é”®å€¼ä¸åŒçš„æ•°æ®ï¼›</p>

<p>åœ¨<strong>JAVA8</strong>ä¸­è€ƒè™‘åˆ°å¦‚æœå“ˆå¸Œå†²çªå¤šçš„æƒ…å†µï¼Œå•é“¾è¡¨<strong>Node</strong>çš„é•¿åº¦ä¼šè¶Šæ¥è¶Šé•¿ï¼Œæ­¤æ—¶é€šè¿‡å•é“¾è¡¨æ¥å¯»æ‰¾å¯¹åº”<strong>Key</strong>å¯¹åº”çš„<strong>Value</strong>çš„æ—¶å€™å°±ä¼šä½¿å¾—æ—¶é—´å¤æ‚åº¦è¾¾åˆ°<strong>O(n)</strong>ï¼Œå› æ­¤åœ¨<strong>JAVA8</strong>ä¸­å¼•å…¥äº†<strong>TreeNode(çº¢é»‘æ ‘)</strong>ï¼Œå½“é“¾è¡¨é•¿åº¦è¶…è¿‡<strong>TREEIFY_THRESHOLD(8)</strong>çš„æ—¶å€™ï¼Œä¼šå°†å•é“¾è¡¨<strong>Node</strong>è½¬æ¢æˆçº¢é»‘æ ‘<strong>TreeNode</strong>ã€‚</p>

<p><em>çº¢é»‘æ ‘æ˜¯ä¸€ç§æ˜“äºå¢åˆ æ”¹æŸ¥çš„äºŒå‰æ ‘ï¼Œä»–å¯¹ä¸æ•°æ®çš„æŸ¥è¯¢çš„æ—¶é—´å¤æ‚åº¦æ˜¯O(logn)ï¼Œæ‰€ä»¥åˆ©ç”¨çº¢é»‘æ ‘çš„ç‰¹ç‚¹å°±å¯ä»¥æ›´é«˜æ•ˆçš„å¯¹ HashMap ä¸­çš„å…ƒç´ è¿›è¡Œæ“ä½œã€‚</em></p>
<h4 id="æ„é€ æ–¹æ³•">æ„é€ æ–¹æ³•</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
</pre></td><td class="rouge-code"><pre>    public HashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    }
    //æ„é€ ä¸€ä¸ªå…·æœ‰æŒ‡å®šçš„åˆå§‹å®¹é‡å’Œé»˜è®¤çš„è´Ÿè½½ç³»æ•°(0.75)çš„ç©ºçš„HashMapï¼Œã€‚
    public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }
    
    //æ„é€ ä¸€ä¸ªå…·æœ‰æŒ‡å®šçš„åˆå§‹å®¹é‡å’Œè´Ÿè½½ç³»æ•°çš„ç©ºçš„HashMapï¼Œ
    public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException("Illegal initial capacity: " +
                                               initialCapacity);
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal load factor: " +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    }
    //æ„é€ ä¸€ä¸ªä¸æŒ‡å®šçš„Mapç›¸åŒé”®å€¼å¯¹æ˜ å°„çš„æ–°çš„HashMapã€‚è¯¥HashMapæ˜¯ç”¨é»˜è®¤çš„è´Ÿè½½ç³»æ•°(0.75)åˆ›å»ºçš„ï¼Œåˆå§‹å®¹é‡è¶³ä»¥å®¹çº³æŒ‡å®šçš„Mapä¸­çš„æ˜ å°„ã€‚
    public HashMap(Map&lt;? extends K, ? extends V&gt; m) {
        this.loadFactor = DEFAULT_LOAD_FACTOR;
        putMapEntries(m, false);
    }
    
    final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) {
        //å¾—åˆ°æ¨å…¥çš„mapå¤§å°
        int s = m.size();
        if (s &gt; 0) {
            if (table == null) { // pre-size
                //æ ¹æ®mapå¤§å°å’Œè´Ÿè½½å› å­è®¡ç®—å‡ºè®¾ç½®çš„å®¹é‡å¤§å°
                float ft = ((float)s / loadFactor) + 1.0F;
                //åˆ¤æ–­å®¹é‡æ˜¯å¦è¶…å‡ºæœ€å¤§å®¹é‡
                int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?
                         (int)ft : MAXIMUM_CAPACITY);
                if (t &gt; threshold)
                    threshold = tableSizeFor(t);
            }
            else if (s &gt; threshold)
                resize();
            for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) {
                K key = e.getKey();
                V value = e.getValue();
                putVal(hash(key), key, value, false, evict);
            }
        }
    }
    //tableSizeForçš„åŠŸèƒ½ï¼ˆä¸è€ƒè™‘å¤§äºæœ€å¤§å®¹é‡çš„æƒ…å†µï¼‰æ˜¯è¿”å›å¤§äºè¾“å…¥å‚æ•°ä¸”æœ€è¿‘çš„2çš„æ•´æ•°æ¬¡å¹‚çš„æ•°ã€‚æ¯”å¦‚10ï¼Œåˆ™è¿”å›16ã€‚
    static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n &gt;&gt;&gt; 1;
        n |= n &gt;&gt;&gt; 2;
        n |= n &gt;&gt;&gt; 4;
        n |= n &gt;&gt;&gt; 8;
        n |= n &gt;&gt;&gt; 16;
        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }
    /**********************ä»¥ä¸‹ä¸¤ä¸ªæ–¹æ³•å¯¹äºæ•´ä¸ªHashMapæå…¶é‡è¦**********************/
    
    //HashMapæ·»åŠ å€¼çš„æ–¹æ³•
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        //åˆ¤æ–­å½“å‰HashMapçš„tableå¤§å°
        if ((tab = table) == null || (n = tab.length) == 0)
            //tableæœªåˆ›å»ºï¼Œè°ƒç”¨resize()è¿›è¡Œåˆå§‹åŒ–(æ‰©å®¹)
            n = (tab = resize()).length;
            
        //å»tableä¸­æœ€åä¸€ä½ä¸hashè¿›è¡ŒæŒ‰ä½ä¸æ“ä½œï¼Œå¾—åˆ°çš„å€¼èµ‹å€¼ç»™iï¼Œ
        //åˆ¤æ–­ä½ç½®çš„å€¼æ˜¯å¦ä¸ºnullï¼Œä¸ºnullåˆ™ä»£è¡¨è¿˜æ²¡æœ‰ä¸æ·»åŠ æ•°æ®é”®å€¼ç›¸åº”çš„hashç›¸åŒçš„æ•°æ®æ¨å…¥è¿‡;
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            //ä¸ºç©ºåˆ™ç›´æ¥å°†é”®å€¼å¯¹æ·»åŠ çš„tableçš„iä½ç½®
            tab[i] = newNode(hash, key, value, null);
        else {
            //è‹¥ä¸ä¸ºç©ºï¼Œåˆ™å¯¹åº”é”®å€¼hashä½ç½®å·²æœ‰æ•°æ®
            //eä»£è¡¨æœ€åå­˜å‚¨çš„é”®å€¼å¯¹
            Node&lt;K,V&gt; e; K k;
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                //é”®å€¼hashç›¸åŒï¼Œé”®å€¼å†…å®¹ä¹Ÿç›¸åŒï¼Œä»£è¡¨å°†å€¼æ›¿æ¢
                e = p;
            else if (p instanceof TreeNode)
                //æ­¤æ—¶på¯¹åº”ä½ç½®çš„æ•°æ®é‡è¶…è¿‡TREEIFY_THRESHOLD(8)ï¼ŒNodeå·²è½¬æ¢ä¸ºTreeNode,æ‰€ä»¥é‡‡ç”¨TreeNodeçš„æ–°å¢èŠ‚ç‚¹æ–¹å¼
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else {
                //æ­¤æ—¶på¯¹åº”ä½ç½®çš„æ•°æ®é‡æœªè¶…è¿‡TREEIFY_THRESHOLD(8)ï¼Œæ‰€ä»¥è¿˜æ²¡è½¬åŒ–æˆçº¢é»‘æ ‘ã€‚ä»æ˜¯ä¸€ä¸ªNodeé“¾è¡¨
                
                //binCountç”¨äºè®¡ç®—å½“å‰é“¾è¡¨çš„èŠ‚ç‚¹æ•°ï¼ŒbinCountä»0å¼€å§‹ï¼Œä»£è¡¨binCount = èŠ‚ç‚¹æ•°+1ï¼›
                for (int binCount = 0; ; ++binCount) {
                    //åˆ¤æ–­æ˜¯å¦åˆ°äº†é“¾è¡¨çš„æœ«å°¾èŠ‚ç‚¹
                    if ((e = p.next) == null) {
                        //åœ¨é“¾è¡¨æœ«å°¾æ·»åŠ æ–°ç”Ÿæˆçš„Node
                        p.next = newNode(hash, key, value, null);
                        //åˆ¤æ–­å½“å‰èŠ‚æ•°æ˜¯å¦è¶…è¿‡TREEIFY_THRESHOLD(8)ï¼Œè¶…è¿‡åˆ™å°†é“¾è¡¨Nodeè½¬æ¢æˆçº¢é»‘æ ‘
                        if (binCount &gt;= TREEIFY_THRESHOLDï¼Œ - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    //åˆ¤æ–­æ˜¯å¦å­˜åœ¨hashç›¸åŒï¼Œkeyå€¼ç›¸åŒçš„é”®å€¼ï¼Œå­˜åœ¨åˆ™è·³å‡ºå¾ªç¯ã€‚
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            //e!=nullä»£è¡¨mapç§å­˜åœ¨keyå€¼ç›¸åŒçš„é”®å€¼ï¼Œå°†å¯¹åº”çš„valuetæ›¿æ¢æˆæ–°çš„ï¼ŒåŒæ—¶è¿”å›æ—§value
            if (e != null) { 
                V oldValue = e.value;
                //onlyIfAbsentè°ƒç”¨æ–¹æ³•æ—¶ä¼ å…¥ï¼Œå¦‚æœä¸ºtrueï¼Œåˆ™ä¸ä¼šè¦†ç›–å€¼
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);//ä¸€ä¸ªå›è°ƒæ–¹æ³•
                return oldValue;
            }
        }
        ++modCount;
        //åˆ¤æ–­æ˜¯å¦éœ€è¦æ‰©å®¹map
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);//ä¸€ä¸ªå›è°ƒæ–¹æ³•
        return null;
    }
    
    //HashMapçš„æ‰©å®¹æ–¹æ³•
    final Node&lt;K,V&gt;[] resize() {
        //è·å¾—å½“å‰table
        Node&lt;K,V&gt;[] oldTab = table;
        //è·å–å½“å‰mapå®¹é‡ï¼Œæ‰©å®¹é˜ˆå€¼
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap &gt; 0) {
            if (oldCap &gt;= MAXIMUM_CAPACITY) {
                //å½“å‰å®¹é‡è¶…è¿‡äº†å¯è®¾çš„æœ€å¤§å€¼
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
                //å®¹é‡ç¿»å€åä¸è¶…è¿‡å¯è®¾æœ€å¤§å®¹é‡ï¼Œæ—§å®¹é‡è¶…è¿‡è¯¾è®¾æœ€å°å®¹é‡
                newThr = oldThr &lt;&lt; 1; // æ‰©å®¹é˜ˆå€¼ä¹Ÿç¿»å€
        }
        else if (oldThr &gt; 0) 
            newCap = oldThr;// æ­¤æ—¶oldCapã€Š=0,ä»£è¡¨hashmapæœªåˆå§‹åŒ–ï¼Œä½†è®¾ç½®äº†æ‰©å®¹é˜ˆå€¼ï¼Œåˆå§‹å®¹é‡è®¾ç½®ä¸ºé˜ˆå€¼
        else {               // åˆå§‹æ‰©å®¹é˜ˆå€¼ä¸º0æ—¶
            newCap = DEFAULT_INITIAL_CAPACITY;//åˆå§‹å®¹é‡ä¸ºé»˜è®¤å®¹é‡(16)
            //åˆå§‹æ‰©å®¹é˜ˆå€¼ = åˆå§‹å®¹é‡(16) * è´Ÿè½½ç³»æ•°/åŠ è½½å› å­(0.75)
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        if (newThr == 0) {
            //ä¸Šé¢ç¬¬äºŒç§æƒ…å†µä¸‹æœªè®¡ç®—æ–°çš„æ‰©å®¹é˜ˆå€¼ï¼Œè¿™é‡Œè®¡ç®—å¹¶èµ‹å€¼
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
        @SuppressWarnings({"rawtypes","unchecked"})
        //æ ¹æ®æ–°çš„å®¹é‡åˆ›å»ºä¸€ä¸ªæ–°çš„table
        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
        table = newTab;
        //å°†ä¹‹å‰çš„æ•°æ®è½¬ç§»åˆ°æ–°çš„table
        if (oldTab != null) {
            for (int j = 0; j &lt; oldCap; ++j) {
                Node&lt;K,V&gt; e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)
                        //è¯¥Nodeåªæœ‰ä¸€ä¸ªæ•°æ®ï¼Œæ ¹æ®hashå’Œå®¹é‡é‡æ–°è®¡ç®—ä¸‹æ ‡æ”¾å…¥æ–°table
                        newTab[e.hash &amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        //è¯¥Nodeæ˜¯ä¸€ä¸ªçº¢é»‘æ ‘Nodeçš„æƒ…å†µ
                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                    else { 
                        //è¯¥Nodeæ˜¯ä¸€ä¸ªæœ‰å¤šä¸ªæ•°æ®çš„é“¾è¡¨(1&lt;æ•°æ®æ•°é‡&lt;TREEIFY_THRESHOLD(8))
                        //loHeadæ˜¯ç”¨æ¥ä¿å­˜æ–°é“¾è¡¨ä¸Šçš„ä½ä½åŒºçš„å¤´å…ƒç´ çš„ï¼ŒloTailæ˜¯ç”¨æ¥ä¿å­˜ä½ä½åŒºçš„å°¾å…ƒç´ çš„ï¼Œ
                        Node&lt;K,V&gt; loHead = null, loTail = null;
                        //hiHeadæ˜¯ç”¨æ¥ä¿å­˜æ–°é“¾è¡¨ä¸Šçš„é«˜ä½åŒºçš„å¤´å…ƒç´ çš„ï¼ŒhiTailæ˜¯ç”¨æ¥ä¿å­˜é«˜ä½åŒºçš„å°¾å…ƒç´ çš„ï¼Œ
                        Node&lt;K,V&gt; hiHead = null, hiTail = null;
                        Node&lt;K,V&gt; next;
                        //è¿›è¡Œé“¾è¡¨éå†è‡³æœ«å°¾èŠ‚ç‚¹ï¼Œè¿™éƒ¨åˆ†å¯èƒ½ä¼šå°†ä¼šå°†å½“å‰é“¾è¡¨åˆ†åˆ—æˆä¸¤ä¸ªé“¾è¡¨ï¼Œå–å†³äºhashçš„ä½æ•°
                        do {
                            next = e.next;
                            //ç­‰äº0æ—¶ï¼Œåˆ™å°†è¯¥å¤´èŠ‚ç‚¹æ”¾åˆ°æ–°æ•°ç»„æ—¶çš„ç´¢å¼•ä½ç½®ç­‰äºå…¶åœ¨æ—§æ•°ç»„æ—¶çš„ç´¢å¼•ä½ç½®,è®°ä¸ºä½ä½åŒºé“¾è¡¨loå¼€å¤´-low;
                            if ((e.hash &amp; oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {//ä¸ç­‰äº0æ—¶,åˆ™å°†è¯¥å¤´èŠ‚ç‚¹æ”¾åˆ°æ–°æ•°ç»„æ—¶çš„ç´¢å¼•ä½ç½®ç­‰äºå…¶åœ¨æ—§æ•°ç»„æ—¶çš„ç´¢å¼•ä½ç½®å†åŠ ä¸Šæ—§æ•°ç»„é•¿åº¦ï¼Œè®°ä¸ºé«˜ä½åŒºé“¾è¡¨hiå¼€å¤´high.
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                            /**
                             * è¿™éƒ¨åˆ†ä¸¾ä¸ªä¾‹å­æ¯”è¾ƒå¥½ç†è§£å‘¢ï¼Œä¸¾ä¸ªä¾‹å­æ¥çœ‹ï¼Œå‡è®¾oldCap = 16 = 10000ï¼Œä¸¤ä¸ªæ•°æ®çš„hashåˆ†åˆ«ä¸ºhash1 = 7 = 0111, hash2 = 23 = 10111
                             * æœªæ‰©å®¹çš„æ—¶å€™ä¸¤ä¸ªhashå¯¹åº”çš„ä¸‹æ ‡åˆ†åˆ«æ˜¯:
                             * (hash1 &amp; oldCap -1) = 0111 &amp; 01111 = 111
                             * (hash2 &amp; oldCap -1) = 10111 &amp; 01111 = 111 æ˜¯åŒæ ·çš„ä½ç½®ï¼›
                             * æ­¤æ—¶æˆ‘ä»¬å°†å®¹é‡æ‰©å¤§ä¸€å€ newCap = 32 = 100000ï¼Œåœ¨æ­¤è®¡ç®—ä¸‹æ ‡
                             * (hash1 &amp; newCap -1) = 0111 &amp; 11111 = 111;ä½ç½®ä¸å˜
                             * hash2 &amp; oldCap -1) = 10111 &amp; 11111 = 10111;ä½ç½®å˜äº†ï¼Œæ¯”åŸæ¥çš„ä½ç½®å¤šäº†10000ï¼Œå³oldCap
                             * å†æ¥ç®—ä»£ç ä¸­çš„e.hash &amp; oldCap == 0è¿™éƒ¨åˆ†
                             * å¯ä»¥çŸ¥é“hash1 &amp; oldCap = 0111 &amp; 10000 = 0ï¼›hash2 &amp; oldCap = 10111 &amp; 10000 = 1ï¼›
                             * æ‰€ä»¥å¯ä»¥å¾—å‡ºï¼Œå¦‚æœe.hash &amp; oldCap == 0ï¼Œé‚£ä¹ˆå¯¹åº”hashçš„Nodeåœ¨è¡¨æ‰©å®¹åä¹Ÿåœ¨æ•°ç»„åŒæ ·çš„ä½ç½®
                             * è€Œe.hash &amp; oldCap != 0çš„Nodeï¼Œåˆ™ä¼šç§»åŠ¨ï¼Œç§»åŠ¨çš„é—´éš”å°±æ˜¯oldCapçš„é•¿åº¦
                             */
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<p>å¯ä»¥çœ‹å‡ºå…¶å®<strong>HashMap</strong>åˆå§‹åŒ–æ—¶æ˜¯ä¸ä¼šåˆå§‹åŒ–æˆ‘ä»¬çš„æ•°æ®è¡¨<strong>table</strong>ï¼Œåªä¼šåˆå§‹åŒ–ä¸€äº›å®¹é‡å¤§å°å’Œè´Ÿè½½å› å­çš„å€¼ï¼Œåœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨æ—¶æ‰ä¼šåˆ›å»ºï¼Œä¾‹å¦‚åœ¨ç¬¬å››ä¸ªæ„é€ å‡½æ•°ï¼Œæ ¹æ®ä¼ å…¥çš„<strong>map</strong>æ„é€ ä¸€ä¸ª<strong>HashMap</strong>ï¼Œè°ƒç”¨<strong>putVal</strong>æ–¹æ³•æ—¶å†…éƒ¨çš„<strong>resize</strong>å‡½æ•°ä¼šåˆå§‹åŒ–<strong>table</strong>ï¼Œå½“å•é“¾è¡¨æ•°æ®é¡¹è¶…è¿‡<strong>TREEIFY_THRESHOLD(8)</strong>ï¼Œä¼šå°†å•é“¾è¡¨<strong>Node</strong>è½¬æ¢æˆçº¢é»‘æ ‘<strong>TreeNode</strong>ï¼Œ<strong>TreeNode</strong>æ¯”è¾ƒå¤æ‚ï¼Œç•™åˆ°æœ€åè®²ã€‚</p>

<p>æ¥ä¸‹æ¥æ¥çœ‹ä¸€äº›å¸¸ç”¨çš„æ–¹æ³•</p>
<h4 id="putkv">put(K,V)</h4>
<p><strong>put(K,V)</strong>:æ¨å…¥æŒ‡å®šçš„é”®å€¼å¯¹çš„æ˜ å°„ã€‚å¦‚æœè¯¥æ˜ å°„å…ˆå‰åŒ…å«äº†è¯¥é”®çš„æ˜ å°„ï¼Œåˆ™æ—§å€¼å°†è¢«æ›¿æ¢ã€‚</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
    
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="removeobject">remove(Object)</h4>
<p><strong>remove(Object)</strong>:ä»è¯¥æ˜ å°„ä¸­ç§»é™¤æŒ‡å®šé”®çš„æ˜ å°„(å¦‚æœå­˜åœ¨)ã€‚</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre></td><td class="rouge-code"><pre>public V remove(Object key) {
        Node&lt;K,V&gt; e;
        return (e = removeNode(hash(key), key, null, false, true)) == null ?
            null : e.value;
    }
    
final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,
                               boolean matchValue, boolean movable) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;
        // åˆ¤æ–­tableå’Œå¯¹åº”çš„keyå€¼Nodeæ˜¯å¦ä¸ºç©º
        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
            (p = tab[index = (n - 1) &amp; hash]) != null) {
            //nodeå­˜æ”¾é”®å€¼ç›¸åŒçš„Node
            Node&lt;K,V&gt; node = null, e; K k; V v;
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                //æ‰¾åˆ°äº†å¯¹åº”çš„Nodeï¼Œæ­¤å¤„ç»“æŸnode = p;
                node = p;
            else if ((e = p.next) != null) {//å½“å‰é“¾è¡¨å¤´ä¸æ˜¯å¯¹åº”çš„é”®å€¼å¯¹æ˜ å°„
                if (p instanceof TreeNode)
                    // å¦‚æœæ˜¯çº¢é»‘æ ‘TreeNodeï¼Œåˆ™åœ¨çº¢é»‘æ ‘å†…å¯»æ‰¾
                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);
                else {
                    //å¦åˆ™åœ¨å•é“¾è¡¨å†…å¾ªç¯æŸ¥æ‰¾ï¼Œæ­¤å¤„ç»“æŸnode = p.next;
                    do {
                        if (e.hash == hash &amp;&amp;
                            ((k = e.key) == key ||
                             (key != null &amp;&amp; key.equals(k)))) {
                            node = e;
                            break;
                        }
                        p = e;
                    } while ((e = e.next) != null);
                }
            }
            //å¦‚æœmatchValueä¸ºtrue,åˆ™åªç§»é™¤valueç›¸ç­‰çš„é”®å€¼å¯¹æ˜ å°„
            if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||
                                 (value != null &amp;&amp; value.equals(v)))) {
                if (node instanceof TreeNode)
                    //è°ƒç”¨çº¢é»‘æ ‘çš„æ–¹å¼ç§»é™¤
                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);
                else if (node == p)
                    //nodeæ˜¯å•é“¾è¡¨å¤´
                    tab[index] = node.next; 
                else
                    //æ­¤æ—¶nodeå°±ä¼šä»å•é“¾è¡¨ä¸­åˆ†ç¦»
                    p.next = node.next;
                ++modCount;
                --size;
                afterNodeRemoval(node);
                return node;
            }
        }
        return null;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="getobject">get(Object)</h4>
<p><strong>get(Object)</strong>:è¿”å›æŒ‡å®šé”®æ˜ å°„åˆ°çš„å€¼ï¼Œå¦‚æœè¯¥æ˜ å°„ä¸åŒ…å«è¯¥é”®çš„æ˜ å°„ï¼Œåˆ™è¿”å›nullã€‚</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre> public V get(Object key) {
        Node&lt;K,V&gt; e;
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    }
    
 final Node&lt;K,V&gt; getNode(int hash, Object key) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
        //åˆ¤æ–­tableæ˜¯å¦ä¸ºç©ºï¼Œæ˜¯å¦å­˜åœ¨æ•°æ®ï¼Œæ˜¯å¦å­˜åœ¨å¯¹åº”é”®å€¼çš„Node
        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
            (first = tab[(n - 1) &amp; hash]) != null) {
            if (first.hash == hash &amp;&amp; // always check first node
                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
                //å•é“¾è¡¨å¤´å°±æ˜¯å¯¹åº”çš„Nodeï¼Œç›´æ¥è¿”å›
                return first;
            //åœ¨é“¾è¡¨å†…æœç´¢hashå’Œkeyå€¼ç›¸åŒçš„Nodeå¹¶è¿”å›
            if ((e = first.next) != null) {
                if (first instanceof TreeNode)
                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
                do {
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        return e;
                } while ((e = e.next) != null);
            }
        }
        return null;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="putallmap-extends-k--extends-v">putAll(Map&lt;? extends K, ? extends V&gt;)</h4>
<p><strong>putAll(Map&lt;? extends K, ? extends V&gt;)</strong>:å°†æŒ‡å®šMapçš„æ‰€æœ‰é”®å€¼å¯¹æ˜ å°„å¤åˆ¶åˆ°æ­¤æ˜ å°„Mapã€‚è¿™äº›æ˜ å°„å°†æ›¿æ¢è¯¥æ˜ å°„å¯¹æŒ‡å®šæ˜ å°„ä¸­å¯¹åº”å­˜åœ¨çš„é”®å€¼å¯¹æ˜ å°„ã€‚</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre> public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
        putMapEntries(m, true);
    }
    
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="clear">clear()</h4>
<p><strong>clear()</strong>:æ¸…ç©º<strong>HashMap</strong>ä¸­çš„æ‰€æœ‰é”®å€¼å¯¹æ˜ å°„ï¼›</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre> public void clear() {
        Node&lt;K,V&gt;[] tab;
        modCount++;
        //å°†tableæ•°ç»„æ¯ä¸€ä½éƒ½è®¾ç½®ä¸ºnull;
        if ((tab = table) != null &amp;&amp; size &gt; 0) {
            size = 0;
            for (int i = 0; i &lt; tab.length; ++i)
                tab[i] = null;
        }
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h2 id="hashtable">HashTable</h2>
<p><strong>Hashtable</strong>ç»§æ‰¿<strong>Map</strong>æ¥å£ï¼Œå®ç°ä¸€ä¸ªkey-valueæ˜ å°„çš„å“ˆå¸Œè¡¨ã€‚ä»»ä½•éç©ºï¼ˆ<strong>non-null</strong>ï¼‰çš„å¯¹è±¡éƒ½å¯ä½œä¸ºkeyæˆ–è€…valueã€‚
<strong>HashTable</strong>çš„çˆ¶ç±»æ¥å£ï¼Œä»¥åŠå†…éƒ¨æœ‰å‡ ä¸ªä¸»è¦çš„å˜é‡ï¼Œå¦‚ä¸‹ï¼š</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre>public class Hashtable&lt;K,V&gt;
    extends Dictionary&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable
//hashæ•°æ®è¡¨
private transient HashtableEntry&lt;?,?&gt;[] table;
//HashTableä¸­çš„æ•°æ®æ•°é‡
private transient int count;
//(threshold = å®¹é‡*è´Ÿè½½ç³»æ•°/åŠ è½½å› å­)æ‰©å®¹é˜ˆå€¼ï¼Œå¯ä»¥è¯´æ˜¯ä¸€ä¸ªæ˜¯å¦éœ€è¦æ‰©å®¹çš„åˆ¤æ–­æ¡ä»¶ï¼Œå½“HashMapçš„size&gt;thresholdæ—¶ä¼šè¿›è¡Œresizeæ“ä½œã€‚
int threshold;
private int threshold;
//è´Ÿè½½ç³»æ•°/åŠ è½½å› å­ï¼Œå¯ä»¥è¯´æ˜¯å½“å‰HashMapæ»¡çš„ç¨‹åº¦ï¼Œ
//å‡è®¾å®ƒç­‰äº0.75ï¼Œé‚£ä¹ˆåœ¨HashMapçš„é”®å€¼å¯¹æ•°é‡è¶…è¿‡å®¹é‡*0.75æ—¶ï¼Œåˆ™ä¼šè¿›è¡Œæ‰©å®¹ã€‚
//ä¿è¯æœ‰è¶³å¤Ÿçš„ç©ºé—´è¿›è¡Œæ•°æ®å­˜æ”¾ï¼ŒåŒæ—¶ä¸ä¼šç»å¸¸è¿›è¡Œæ‰©å®¹ã€‚
final float loadFactor;
private float loadFactor;

//å¯åˆ†é…çš„å†…éƒ¨æ•°ç»„çš„æœ€å¤§å¤§å°
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
</pre></td></tr></tbody></table></code></pre></div></div>
<p><strong>HashtableEntry</strong>:HashTableçš„æ•°æ®åŸºç±»</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="rouge-code"><pre> private static class HashtableEntry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
    // END Android-changed: Renamed Entry -&gt; HashtableEntry.
        final int hash;
        final K key;
        V value;
        HashtableEntry&lt;K,V&gt; next;

        protected HashtableEntry(int hash, K key, V value, HashtableEntry&lt;K,V&gt; next) {
            this.hash = hash;
            this.key =  key;
            this.value = value;
            this.next = next;
        }

        @SuppressWarnings("unchecked")
        protected Object clone() {
            return new HashtableEntry&lt;&gt;(hash, key, value,
                                  (next==null ? null : (HashtableEntry&lt;K,V&gt;) next.clone()));
        }

        // Map.Entry Ops

        public K getKey() {
            return key;
        }

        public V getValue() {
            return value;
        }

        public V setValue(V value) {
            if (value == null)
                throw new NullPointerException();

            V oldValue = this.value;
            this.value = value;
            return oldValue;
        }

        public boolean equals(Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;

            return (key==null ? e.getKey()==null : key.equals(e.getKey())) &amp;&amp;
               (value==null ? e.getValue()==null : value.equals(e.getValue()));
        }

        public int hashCode() {
            return hash ^ Objects.hashCode(value);
        }

        public String toString() {
            return key.toString()+"="+value.toString();
        }
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<p><strong>HashTable</strong>ä¸<strong>HashMap</strong>éå¸¸ç›¸ä¼¼ï¼Œæœ‰å¾ˆå¤šä½œç”¨ä¸€æ ·çš„å˜é‡ã€‚</p>
<h4 id="æ„é€ æ–¹æ³•-1">æ„é€ æ–¹æ³•</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
</pre></td><td class="rouge-code"><pre> //æ„é€ ä¸€ä¸ªæ–°çš„Hashtableï¼Œå…·æœ‰é»˜è®¤çš„åˆå§‹å®¹é‡(11)å’ŒåŠ è½½ç³»æ•°(0.75)ã€‚
 public Hashtable() {
        this(11, 0.75f);
    }
    
 //æ„é€ ä¸€ä¸ªæŒ‡å®šåˆå§‹å®¹é‡çš„æ–°çš„Hashtableï¼Œå…·æœ‰é»˜è®¤çš„åŠ è½½ç³»æ•°(0.75)ã€‚
 public Hashtable(int initialCapacity) {
        this(initialCapacity, 0.75f);
    }
    
 //æ„é€ ä¸€ä¸ªæŒ‡å®šåˆå§‹å®¹é‡å’ŒæŒ‡å®šåŠ è½½ç³»æ•°çš„æ–°çš„Hashtableã€‚
 public Hashtable(int initialCapacity, float loadFactor) {
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal Load: "+loadFactor);

        if (initialCapacity==0)
            initialCapacity = 1;
        this.loadFactor = loadFactor;
        table = new HashtableEntry&lt;?,?&gt;[initialCapacity];
        threshold = (int)Math.min(initialCapacity, MAX_ARRAY_SIZE + 1);
    }

 //æ ¹æ®ä¼ å…¥çš„Mapä¸€ä¸ªæ–°çš„HashTableã€‚HashTableçš„åˆå§‹å®¹é‡è¶³ä»¥å®¹çº³ç»™å®šMapä¸­çš„æ˜ å°„æ•°æ®ï¼Œå¹¶å…·æœ‰é»˜è®¤çš„åŠ è½½å› å­(0.75)ã€‚
 public Hashtable(Map&lt;? extends K, ? extends V&gt; t) {
        this(Math.max(2*t.size(), 11), 0.75f);
        putAll(t);
    }
     
 public synchronized void putAll(Map&lt;? extends K, ? extends V&gt; t) {
        for (Map.Entry&lt;? extends K, ? extends V&gt; e : t.entrySet())
            put(e.getKey(), e.getValue());
    }
    
 //æ·»åŠ é”®å€¼å¯¹ï¼Œæ˜¯ä¸€ä¸ªåŒæ­¥çš„æ–¹æ³•
 public synchronized V put(K key, V value) {
        //ç¦æ­¢æ·»åŠ ç©ºçš„value
        if (value == null) {
            throw new NullPointerException();
        }

        HashtableEntry&lt;?,?&gt; tab[] = table;
        int hash = key.hashCode();
        //æ ¹æ®keyçš„hashå€¼å’Œè¡¨å®¹é‡è®¡ç®—ä¸‹æ ‡
        //0x7FFFFFFFæ˜¯ä¸€ä¸ªç”¨16è¿›åˆ¶è¡¨ç¤ºçš„æ•´å‹,æ˜¯æ•´å‹é‡Œé¢çš„æœ€å¤§å€¼
        //è½¬æˆ2è¿›åˆ¶ç”±31ä¸ª1ç»„æˆï¼Œè€Œæ•´å½¢çš„æœ€é«˜æ˜¯32ä½
        //hashä¸å…¶æŒ‰ä½ä¸å¾—åˆ°ä¸€ä¸ªæ­£æ•°
        int index = (hash &amp; 0x7FFFFFFF) % tab.length;
        @SuppressWarnings("unchecked")
        //è·å¾—å¯¹åº”ä¸‹æ ‡çš„å•é“¾è¡¨
        HashtableEntry&lt;K,V&gt; entry = (HashtableEntry&lt;K,V&gt;)tab[index];
        //å¦‚æœå­˜åœ¨keyå€¼ç›¸åŒçš„é”®å€¼å¯¹ï¼Œåˆ™æ›¿æ¢value
        for(; entry != null ; entry = entry.next) {
            if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) {
                V old = entry.value;
                entry.value = value;
                return old;
            }
        }
        
        addEntry(hash, key, value, index);
        return null;
    }
    
private void addEntry(int hash, K key, V value, int index) {
        modCount++;

        HashtableEntry&lt;?,?&gt; tab[] = table;
        //åˆ¤æ–­å½“å‰å®¹é‡æ˜¯å¦è¶…å‡ºæˆ–ç­‰äºæ‰©å®¹é˜ˆå€¼
        if (count &gt;= threshold) {
            // å¦‚æœè¶…è¿‡é˜ˆå€¼ï¼Œåˆ™æ‰©å®¹
            rehash();
            
            //æ‰©å®¹åé‡æ–°è®¡ç®—ä¸‹æ ‡index
            tab = table;
            hash = key.hashCode();
            index = (hash &amp; 0x7FFFFFFF) % tab.length;
        }

        //åˆ›å»ºæ–°çš„HashtableEntryï¼Œå¹¶èµ‹å€¼
        @SuppressWarnings("unchecked")
        HashtableEntry&lt;K,V&gt; e = (HashtableEntry&lt;K,V&gt;) tab[index];
        tab[index] = new HashtableEntry&lt;&gt;(hash, key, value, e);
        //æ•°æ®é‡+1
        count++;
    }
    
  //æ‰©å®¹ï¼Œå¹¶å¯¹å†…éƒ¨çš„é”®å€¼å¯¹é‡æ–°æ’åˆ—
  protected void rehash() {
        int oldCapacity = table.length;
        HashtableEntry&lt;?,?&gt;[] oldMap = table;

        //æ–°å®¹é‡ä¸ºä¸¤å€æ—§å®¹é‡+1
        int newCapacity = (oldCapacity &lt;&lt; 1) + 1;
        //åˆ¤æ–­æ–°å®¹é‡æ˜¯å¦è¶…å‡ºæœ€å¤§å®¹é‡
        if (newCapacity - MAX_ARRAY_SIZE &gt; 0) {
            if (oldCapacity == MAX_ARRAY_SIZE)
                // Keep running with MAX_ARRAY_SIZE buckets
                return;
            newCapacity = MAX_ARRAY_SIZE;
        }
        //ä½¿ç”¨æ–°å®¹é‡åˆ›å»ºä¸€ä¸ªæ–°çš„æ•°ç»„table
        HashtableEntry&lt;?,?&gt;[] newMap = new HashtableEntry&lt;?,?&gt;[newCapacity];

        modCount++;
        //è®¡ç®—æ–°çš„æ‰©å®¹é˜ˆå€¼
        threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);
        table = newMap;
        
        //å°†æ—§mapæ•°ç»„çš„æ•°æ®å¯¼å…¥æ–°mapæ•°ç»„,é‡æ–°è®¡ç®—ä¸‹æ ‡
        for (int i = oldCapacity ; i-- &gt; 0 ;) {
            for (HashtableEntry&lt;K,V&gt; old = (HashtableEntry&lt;K,V&gt;)oldMap[i] ; old != null ; ) {
                HashtableEntry&lt;K,V&gt; e = old;
                old = old.next;

                int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity;
                e.next = (HashtableEntry&lt;K,V&gt;)newMap[index];
                newMap[index] = e;
            }
        }
    }
    
</pre></td></tr></tbody></table></code></pre></div></div>
<p>å¯ä»¥çœ‹å‡ºå…¶å®<strong>HashTable</strong>ä¸<strong>HashMap</strong>çš„åˆå§‹åŒ–ç±»ä¼¼ï¼Œåœ¨åˆå§‹åŒ–æ—¶æ˜¯ä¸ä¼šåˆå§‹åŒ–æˆ‘ä»¬çš„æ•°æ®è¡¨<strong>table</strong>ï¼Œåªä¼šåˆå§‹åŒ–ä¸€äº›å®¹é‡å¤§å°å’Œè´Ÿè½½å› å­çš„å€¼ï¼Œåœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨æ—¶æ‰ä¼šåˆ›å»ºã€‚ä¾‹å¦‚<strong>putAll</strong>ã€‚</p>
<h4 id="putkv-1">put(K,V)</h4>
<p><strong>put(K,V)</strong>:æ¨å…¥æŒ‡å®šçš„é”®å€¼å¯¹çš„æ˜ å°„ã€‚å¦‚æœè¯¥æ˜ å°„å…ˆå‰åŒ…å«äº†è¯¥é”®çš„æ˜ å°„ï¼Œåˆ™æ—§å€¼å°†è¢«æ›¿æ¢ã€‚<strong>key</strong>å’Œ<strong>value</strong>éƒ½ä¸èƒ½ä¸ºnullã€‚</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre> public synchronized V put(K key, V value) {
        //ç¡®ä¿valuä¸ä¸ºnull
        if (value == null) {
            throw new NullPointerException();
        }

        HashtableEntry&lt;?,?&gt; tab[] = table;
        //è®¡ç®—ä¸‹æ ‡
        int hash = key.hashCode();
        int index = (hash &amp; 0x7FFFFFFF) % tab.length;
        @SuppressWarnings("unchecked")
        //è·å¾—å¯¹åº”ä¸‹æ ‡çš„å•é“¾è¡¨
        HashtableEntry&lt;K,V&gt; entry = (HashtableEntry&lt;K,V&gt;)tab[index];
        //å¦‚æœå­˜åœ¨åœ¨keyå€¼å·²å­˜åœ¨ï¼Œåˆ™æ›¿æ¢value
        for(; entry != null ; entry = entry.next) {
            if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) {
                V old = entry.value;
                entry.value = value;
                return old;
            }
        }
        //ä¸å­˜åœ¨æ·»åŠ é”®å€¼å¯¹
        addEntry(hash, key, value, index);
        return null;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="removeobject-1">remove(Object)</h4>
<p><strong>remove(Object)</strong>:ä»è¿™ä¸ª<strong>HashTable</strong>ç§»é™¤<strong>key</strong>(åŠå…¶å¯¹åº”çš„<strong>value</strong>)ã€‚å¦‚æœ<strong>key</strong>ä¸åœ¨<strong>HashTable</strong>ä¸­ï¼Œæ­¤æ–¹æ³•ä¸æ‰§è¡Œä»»ä½•æ“ä½œã€‚</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre> public synchronized V remove(Object key) {
        //è®¡ç®—ä¸‹æ ‡
        HashtableEntry&lt;?,?&gt; tab[] = table;
        int hash = key.hashCode();
        int index = (hash &amp; 0x7FFFFFFF) % tab.length;
        
        @SuppressWarnings("unchecked")
        HashtableEntry&lt;K,V&gt; e = (HashtableEntry&lt;K,V&gt;)tab[index];
        //åˆ¤æ–­æ˜¯å¦å­˜åœ¨å¯¹åº”çš„keyå€¼
        for(HashtableEntry&lt;K,V&gt; prev = null ; e != null ; prev = e, e = e.next) {
            if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {
                modCount++;
                if (prev != null) {
                    prev.next = e.next;
                } else {
                    tab[index] = e.next;
                }
                count--;
                V oldValue = e.value;
                e.value = null;
                return oldValue;
            }
        }
        return null;
    }

</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="getobject-1">get(Object)</h4>
<p><strong>get(Object)</strong>:è¿”å›æŒ‡å®š<strong>key</strong>å¯¹åº”çš„<strong>value</strong>,è‹¥<strong>key</strong>ä¸åœ¨<strong>HashTable</strong>ä¸­ï¼Œåˆ™è¿”å›<strong>null</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre> public synchronized V get(Object key) {
        //è®¡ç®—ä¸‹æ ‡
        HashtableEntry&lt;?,?&gt; tab[] = table;
        int hash = key.hashCode();
        int index = (hash &amp; 0x7FFFFFFF) % tab.length;
        //æ‰¾keyå¯¹åº”çš„value
        for (HashtableEntry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) {
            if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {
                return (V)e.value;
            }
        }
        return null;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="clear-1">clear()</h4>
<p><strong>clear()</strong>:æ¸…ç©ºæ­¤<strong>HashTable</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>  public synchronized void clear() {
        HashtableEntry&lt;?,?&gt; tab[] = table;
        modCount++;
        for (int index = tab.length; --index &gt;= 0; )
            tab[index] = null;
        count = 0;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<p><strong>HashTable</strong>çš„æ–¹æ³•åŸºæœ¬éƒ½æ˜¯<strong>synchronized</strong>çš„ï¼Œç›¸å¯¹äº<strong>HashMap</strong>æ˜¯åŒæ­¥çš„ã€‚</p>
<h2 id="hashmapä¸hashtableçš„ä¸åŒ">HashMapä¸HashTableçš„ä¸åŒ</h2>
<h3 id="ä¸€-çº¿ç¨‹å®‰å…¨æ€§">ä¸€ çº¿ç¨‹å®‰å…¨æ€§</h3>
<ul>
  <li><strong>HashTable</strong>æ–¹æ³•æ·»åŠ äº†<strong>synchronized</strong>å…³é”®å­—ï¼Œæ˜¯åŒæ­¥çš„ï¼Œæ˜¯çº¿ç¨‹å®‰å…¨çš„</li>
  <li>
    <ul>
      <li><strong>HashMap</strong>æ˜¯éåŒæ­¥çš„ï¼Œçº¿ç¨‹ä¸å®‰å…¨</li>
    </ul>
  </li>
</ul>

<h3 id="äºŒ-å†…éƒ¨æ–¹æ³•">äºŒ å†…éƒ¨æ–¹æ³•</h3>
<ul>
  <li><strong>Hashtable</strong>åˆ™ä¿ç•™äº†<strong>contains</strong>ï¼Œ<strong>containsValue</strong>å’Œ<strong>containsKey</strong>ä¸‰ä¸ªæ–¹æ³•ï¼Œå…¶ä¸­<strong>contains</strong>å’Œ<strong>containsValue</strong>åŠŸèƒ½ç›¸åŒã€‚</li>
  <li><strong>HashMap</strong>æ²¡æœ‰<strong>contains</strong>æ–¹æ³•å»æ‰äº†ï¼Œæ”¹æˆ<strong>containsValue</strong>å’Œ<strong>containsKey</strong>ï¼Œå› ä¸º<strong>contains</strong>æ–¹æ³•å®¹æ˜“è®©äººå¼•èµ·è¯¯è§£ã€‚</li>
</ul>

<p>æ–¹æ³•å†…å®¹å¯¹æ¯”ï¼š
<strong>HashTable</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="rouge-code"><pre>  
  public synchronized boolean contains(Object value) {
        //valueä¸èƒ½ä¸ºnull
        if (value == null) {
            throw new NullPointerException();
        }
        //åŒ…å«è¿”å›true,ä¸åŒ…å«è¿”å›false
        HashtableEntry&lt;?,?&gt; tab[] = table;
        for (int i = tab.length ; i-- &gt; 0 ;) {
            for (HashtableEntry&lt;?,?&gt; e = tab[i] ; e != null ; e = e.next) {
                if (e.value.equals(value)) {
                    return true;
                }
            }
        }
        return false;
    }
  //æŸ¥çœ‹æ˜¯å¦åŒ…å«value
  public boolean containsValue(Object value) {
        return contains(value);
    }
    
  //æŸ¥çœ‹æ˜¯å¦åŒ…å«key
  public synchronized boolean containsKey(Object key) {
        HashtableEntry&lt;?,?&gt; tab[] = table;
        int hash = key.hashCode();
        int index = (hash &amp; 0x7FFFFFFF) % tab.length;
        for (HashtableEntry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) {
             //åŒ…å«è¿”å›true,ä¸åŒ…å«è¿”å›false
            if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {
                return true;
            }
        }
        return false;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<p><strong>HashMap</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre> public boolean containsValue(Object value) {
        Node&lt;K,V&gt;[] tab; V v;
        if ((tab = table) != null &amp;&amp; size &gt; 0) {
            for (int i = 0; i &lt; tab.length; ++i) {
                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) {
                    if ((v = e.value) == value ||
                        (value != null &amp;&amp; value.equals(v)))
                        return true;
                }
            }
        }
        return false;
    }

  public boolean containsKey(Object key) {
        return getNode(hash(key), key) != null;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h3 id="keyå’Œvalueçš„é™åˆ¶">keyå’Œvalueçš„é™åˆ¶</h3>
<p>æ ¹æ®ä¸Šé¢çš„<strong>containsValue</strong>å’Œ<strong>containsKey</strong>æ–¹æ³•å¾—å‡ºï¼š
<strong>Hashtable</strong>:<strong>key</strong>å’Œ<strong>value</strong>éƒ½ä¸å…è®¸å‡ºç°<strong>null</strong>å€¼ï¼›
<strong>HashMap</strong>:<strong>null</strong>å¯ä»¥ä½œä¸º<strong>key</strong>ï¼Œè¿™æ ·çš„<strong>key</strong>åªæœ‰ä¸€ä¸ªï¼›ä½†æ˜¯å¯ä»¥æœ‰ä¸€ä¸ªæˆ–å¤šä¸ª<strong>key</strong>æ‰€å¯¹åº”çš„å€¼ä¸º<strong>null</strong>ã€‚å½“<strong>get()</strong>æ–¹æ³•è¿”å›n<strong>ull</strong>å€¼æ—¶ï¼Œå¯èƒ½æ˜¯ <strong>HashMap</strong>ä¸­æ²¡æœ‰è¯¥é”®ï¼Œä¹Ÿå¯èƒ½ä½¿è¯¥é”®æ‰€å¯¹åº”çš„å€¼ä¸º<strong>null</strong>ã€‚å› æ­¤ï¼Œåœ¨<strong>HashMap</strong>ä¸­ä¸èƒ½ç”±<strong>get()</strong>æ–¹æ³•æ¥åˆ¤æ–­<strong>HashMap</strong>ä¸­æ˜¯å¦å­˜åœ¨æŸä¸ª<strong>key</strong>ï¼Œ è€Œåº”è¯¥ç”¨<strong>containsKey()</strong>æ–¹æ³•æ¥åˆ¤æ–­ã€‚</p>
<h3 id="ä¸¤ä¸ªéå†æ–¹å¼çš„å†…éƒ¨å®ç°ä¸Šä¸åŒ">ä¸¤ä¸ªéå†æ–¹å¼çš„å†…éƒ¨å®ç°ä¸Šä¸åŒ</h3>
<p><strong>Hashtable</strong>:ä½¿ç”¨äº† <strong>Iterator</strong>
<strong>HashMap</strong>:ä½¿ç”¨äº† <strong>Iterator</strong>ã€‚ç”±äºå†å²åŸå› ï¼Œè¿˜ä½¿ç”¨äº†<strong>Enumeration</strong>çš„æ–¹å¼ ã€‚</p>
<h3 id="hashå€¼ä¸åŒ">hashå€¼ä¸åŒ</h3>
<p><strong>Hashtable</strong>:ç›´æ¥ä½¿ç”¨å¯¹è±¡çš„<strong>hashCode</strong>,<strong>hashCode</strong>æ˜¯jdkæ ¹æ®å¯¹è±¡çš„åœ°å€æˆ–è€…å­—ç¬¦ä¸²æˆ–è€…æ•°å­—ç®—å‡ºæ¥çš„<strong>int</strong>ç±»å‹çš„æ•°å€¼ã€‚<strong>Hashtable</strong>åœ¨æ±‚<strong>hash</strong>å€¼å¯¹åº”çš„ä½ç½®ç´¢å¼•æ—¶ï¼Œç”¨å–æ¨¡è¿ç®—;
<strong>HashMap</strong>:é‡æ–°è®¡ç®—<strong>hash</strong>å€¼,åœ¨æ±‚ä½ç½®ç´¢å¼•æ—¶ï¼Œåˆ™ç”¨ä¸è¿ç®—;</p>

<h3 id="å†…éƒ¨å®ç°ä½¿ç”¨çš„æ•°ç»„åˆå§‹åŒ–å’Œæ‰©å®¹æ–¹å¼ä¸åŒ">å†…éƒ¨å®ç°ä½¿ç”¨çš„æ•°ç»„åˆå§‹åŒ–å’Œæ‰©å®¹æ–¹å¼ä¸åŒ</h3>
<p><strong>Hashtable</strong>:åœ¨ä¸æŒ‡å®šå®¹é‡çš„æƒ…å†µä¸‹çš„é»˜è®¤å®¹é‡ä¸º11,<strong>Hashtable</strong>ä¸è¦æ±‚åº•å±‚æ•°ç»„çš„å®¹é‡ä¸€å®šè¦ä¸º2çš„æ•´æ•°æ¬¡å¹‚;æ‰©å®¹æ—¶ï¼Œ<strong>Hashtable</strong>å°†å®¹é‡å˜ä¸ºåŸæ¥çš„2å€åŠ 1
<strong>HashMap</strong>:åœ¨ä¸æŒ‡å®šå®¹é‡çš„æƒ…å†µä¸‹çš„é»˜è®¤å®¹é‡ä¸º16,<strong>HashMap</strong>è¦æ±‚åº•å±‚æ•°ç»„çš„å®¹é‡ä¸€å®šä¸º2çš„æ•´æ•°æ¬¡å¹‚,æ‰©å®¹æ—¶ï¼Œ<strong>HashMap</strong>å°†å®¹é‡å˜ä¸ºåŸæ¥çš„2å€ã€‚</p>

<h2 id="treemap">TreeMap</h2>
<p><strong>TreeMap</strong>æ˜¯ä¸€ä¸ªéåŒæ­¥æœ‰åºçš„<strong>key-value</strong>é›†åˆï¼Œå®ƒé€šè¿‡<strong>çº¢é»‘æ ‘</strong>å®ç°ï¼Œå®ç°äº†<strong>NavigableMap</strong>æ¥å£ï¼Œæ„å‘³ç€å®ƒæ”¯æŒä¸€ç³»åˆ—çš„å¯¼èˆªæ–¹æ³•ã€‚æ¯”å¦‚è¿”å›<strong>æœ‰åºçš„keyé›†åˆ</strong>ã€‚è¯¥æ˜ å°„æ ¹æ®å…¶é”®çš„è‡ªç„¶é¡ºåºè¿›è¡Œæ’åºï¼Œæˆ–è€…æ ¹æ®åˆ›å»ºæ˜ å°„æ—¶æä¾›çš„ <strong>Comparator</strong> è¿›è¡Œæ’åºï¼Œå…·ä½“å–å†³äºä½¿ç”¨çš„æ„é€ æ–¹æ³•ã€‚
<strong>TreeMap</strong>çš„åŸºæœ¬æ“ä½œ <strong>containsKey</strong>ã€<strong>get</strong>ã€<strong>put</strong> å’Œ <strong>remove</strong> çš„æ—¶é—´å¤æ‚åº¦æ˜¯ <strong>log(n)</strong> ã€‚ä½¿ç”¨ä¸å¤šï¼Œå°±æš‚ä¸ä»‹ç»äº†ã€‚</p>
:ET